## 1. 학습 날짜
+ 2020-12-16(수)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ 알고리즘 분석

## 4. 동료 학습 방법


## 5. 학습 목표
+ Greedy 알고리즘 학습
+ Backtracking 알고리즘 학습
+ Bound and Branch 알고리즘 학습
+ 정렬 및 검색 알고리즘 학습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 알고리즘 분석 강의 수강 : 5시간    

    
### Greedy Algorithm      
     
- 신장트리    
트리는 사이클이 존재하지 않는다    
트리의 엣지 개수 = 노드 -1    
    
- 최소비용신장트리    
    
1. Prim의 알고리즘    
알고리즘의 정확성을 설명하는 것은 복잡하다.    
증명은 훑어보는 정도로 공부하면 된다.    
    
2. Kruskal의 알고리즘    
find(i) -> i가 속해있는 집합을 return    
    
두 알고리즘의 비교    
sparse => real world는 매우 sparse. 지역적인 문제, 사람간의 관계 -> 에지단위로 판단하는 Kruskal은 모든 노드를 조사할 필요가 없어 효과적이다.    
dense => 에지개수가 늘어나는 문제 -> 노드기준으로 하는(노드 간의 관계를 보는) Prims가 더 효과적이다.    
     
    
- Dijkstra 의 알고리즘    
    
- Huffman code    
허프만코드는 optimal binary code 이면서 전치코드이다.    
    
prefix(전치) : 문자열의 앞에서부터 읽은 한 부분    
prefix code : 한 문자가 다른 문자의 앞부분이 될 수 없는 코드    
    
한번 결정된 사항은 뒤에서 바뀌지 않는다.    
Min heap 을 이용해서 데이터를 저장한다. root에서 가장 작은 값이 저장된다.    
    
- 0-1 knapsack problem    
배낭의 무게의 한도를 넘지 않으면서, 물건들의 가치의 총합을 극대화하는 문제    
아이템을 자르는 것은 불가.    
어떻게 물건을 선정할 것인가?    
고전적인 문제이면서도, 어려운 문제로 알려져있다.    
    
- 0-1 knapsack 은 탐욕적인방법으로 해결하지 못하지만,    
- fractional은 탐욕적인 방법으로 해결할 수 있다.    
연속적인 문제가 이산적인 문제보다 해결하기 수월하다    
    
0-1은 탐욕적인 방법으로 해결할 수 없고, 대신 동적계획적인 방법으로 해결할 수 있다.    
    
- 상호배타적 집합의 처리(Disjoint Sets Algorithm)    
    
(page 87) union을 하기위해 연결하는 포인터 조작은 고려하지 않는다.    
즉, 여기서 말하는 포인터 이동은 find()에 필요한 포인터 이동만을 고려한다.    
  
-------------------------------------------------------    
    
### Backtracking 
    
- Tree travel    
    
- 4-Queens problem    
    
- n-Queens problem    
       
    
- 부분집합의 합 구하기    
    
- 그래프 색칠하기    
평면에 그릴 수 있는 그래프 : planner graph    
모든 그래프는 평면에 그릴 수 있는 것은 아니다. 평면에 교차하는 에지가 없도록 그릴 수 없는 그래프가 존재한다. non-planner graph     
    
우리나라 시도 또한 4개의 색깔로도 표현가능하다.    
    
--------------------------------------------------------------

### Branch-and-Bound    
    
최적해는 한개이거나 동일한 값을 갖을 때는 여러개가 될 수 있다.    
    
- 0-1 Knapsack Problem    
backtracking에 bound 개념을 추가시킨것    
    
bound ≤ maxprofit 이면 수준 i에 있는 마디는 유망하지 않다    
bound == maxprofit이여도 유망하지 않다. 굳이 찾은 값이 같은데, 새로운 쪽으로 갈 필요가 없기 때문이다.    
    
    
- 분기한정 가지치기로 너비우선검색    
    
- 분기한정 가지치기로 최고우선검색(best-first search)    
max heap을 배열로 저장할 수 있다.    
max heap 에서 가장 큰 노드가 root이고, 부모노드는 그 자식노드보다 값이 크다.    
log의 밑은 2    
    
- TSP     
매우 많은 가능성이 있기 때문에, 단순한 방법으로는 문제를 해결할 수 없다.    
    
- 근사 알고리즘    
굉장히 풀기 어려운 문제는 근사 알고리즘을 통해  현실적으로 문제를 풀 수 있는 시간내의 해답의 근사값을 알아내는 것.    
  
----------------------------------------------------------------
  
### Sorting

<7. 계산복잡도의 소개 : 정렬문제>    
    
알고리즘마다 제자리정렬일 수도 있고, 아닐수도 있다.    
    
- 삽입 정렬    
    
- 선택 정렬    
    
- 교환 정렬    
    
- 버블 정렬       
    
- 한번 비교하는데 최대한 하나의 역을 제거하는 알고리즘의 하한선 ### 다시 듣기 ###    
    
nC2 = n(n-1)/2    
    
한번의 비교라는 것은 천칭을 한번 사용하는 것을 의미한다.    
    
선택정렬은 한번의 비교로 자리가 바뀌지 않으나, 내부적으론는 하나의 역이 제거되는 꼴이 된다.    
    
퀵소트도 합병정렬과 마찬가지로 한번의 비교시 하나 이상의 역을 제거한다.    
퀵소트 추가공간: 평균적으로 Θ(lg n)-  재귀에 의한 인덱스 저장공간    
    
    
- binary tree의 종류    
    
힙정렬은 실질적인 완전이진트리로 구성하게 된다.    
트리구조를 내부에 명시적으로 가지고 있지 않아도, 배열의 인덱스를 통해 트리를 해석할 수 있다는 장점이 있다.    
    
O(1): 항상 일정한 시간에 찾을 수 있다는 의미    
    
- Shiftdown    
형제노드 중 큰 노드를 선택하여 부모노드와 교체    
    
- heap sort    
makeheap : 방법2가 더 효과적이다    
제자리정렬 알고리즘    
    
removekeys    
    
- 키의 비교만으로 정렬하는 경우 하한    
교환정렬에는 불필요한 비교가 존재한다.    
결정트리    
     
보조정리7.1 : 우리가 보통 쓰는 알고리즘은 모두 결정적 알고리즘이다.    
보조정리 7.1~7.4    
-> 키를 이용한 비교 정렬알고리즘의 하한은 오메가(nlgn)    
    
- 분배에 의한 정렬 : 기수정렬 (키에 대한 어느정도의 정보가 있다)    
오른쪽에서 왼쪽 자리순 : 3(digit수) * 10(데이터개수) 만큼의 공간이 필요하다.    
    
- topological Sort(선후관계가 있는 데이터의 정렬)    
print top(S) : 스택에 가장 위에 쌓인 노드 부터 출력된다.    
A->B->C인 경우 C->B->A순으로 출력된다.    
    
----------------------------------------------------------------      
    
### Searching     
    
결론은 이분검색이 가장 좋은 검색이다.    
    
- 보간 검색    
데이터의 분포에 따라 mid를 결정한다.    
데이터가 골고루 분포되지 못한 경우, 좋은 효과를 얻지 못함.    
    
- 보강된 보간 검색법    
mid값을 양쪽 인덱스에서 떨어지도록 임의적으로 구성한다.    
이를 통해 아이템을 균등하게 분포시킬 수 있다.    
    
- 트리구조를 사용한 동적검색    
동적검색은 배열로 검색하기 불가능하다. 이경우 트리를  사용한다.    
     
- 검색시간 향상을 위한 트리구조    
이진트리의 균형을 유지할 수록(루트로부터 거리가 멀지 않도록) 검색 시간이 빨라진다.    
AVL    
B-Tree    
    
- 해슁    
    
- 선택 문제    
키가 정렬되어 있지 않다고 가정.    
    
- 문자열 매칭    
패턴이 긴것을 찾는 것을 사실 의미가 없기 때문에 텍스트에 비해 매우 작은 패턴을 찾는다고 가정함    
    

## 7. 학습 내용에 대한 개인적인 총평
+ 알고리즘 분석 기말고사 범위를 학습하였다. 
+ Greedy, Backtracking, Bound and Branch 알고리즘 내용을 정리하였다.
+ 검색과 탐색 알고리즘에 대한 내용을 정리하였다.
+ 알고리즘분석 수업에서 학습한 내용은 시험이 끝나도 개념을 잊어버리지 않도록 복습을 꾸준히 수행할 계획이다.
+ 앞으로 다양한 알고리즘 문제를 풀어야겠다.


## 8. 다음 학습 계획
+ 이산구조 시험대비