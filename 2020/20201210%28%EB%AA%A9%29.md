## 1. 학습 날짜
+ 2020-12-10(목)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ 소프트웨어공학 설계 및 구현

## 4. 동료 학습 방법

## 5. 학습 목표
+ 소프트웨어공학 설계 및 구현 단계 학습


## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 소프트웨어공학 강의 수강 : 3시간    

    
 12장 소프트웨어 설계   
   
설계는 관리적인 관점에서 크게 두 단계로 나눌 수 있다.   
첫 번째 단계인 기본 설계(preliminary design, 상위 설계) 단계에서는 소프트웨어 시스템의 구조와 데이터를 규명하며 사용자 인터페이스를 정의한다. 알고리즘 없음. 기본설계는 일반적으로 설계에 대한 경험이 많은 엔지니어가 수행. 그 이후에 이루어지는 상세 설계(detail design) 단계에서는 각 모듈의 구체적인 알고리즘에 초점을 맞추게 된다. 상세 설계는 각 개발자가 분담하여 수행.   
소프트웨어 설계는 소프트웨어에 할당된 서브시스템을 설계하는 과정이다. 서브시스템은 일반적으로 자료와 제어 구조를 포함하며 독립적으로 기능을 수행할 수 있고 컴파일될 수 있는 프로그램 구성요소를 일컫는다.   
   
설계의 기술적인 관점 4가지로는 데이터 설계, 구조 설계, 프로시저 설계, 사용자 인터페이스 설계가 있다.   
1.	데이터 설계   
요구사항 분석 단계의 정보 모델링에서 밝혀진 정보를 이용하여 자료구조와 DB를 설계한다.   
2.	구조 설계   
기능 모델링과 동적 모델링에 나타난 결과를 이용하여 프로그램 구조상에 있는 각 모듈들 사이의 관계를 기술한다   
3.	프로시저 설계   
각 모듈의 내부가 구체적으로 밝혀지며 어떤 알고리즘을 사용할지 결정한다.   
4.	사용자 인터페이스 설계   
사용자가 시스템의 기능에 접근할 수 있도록 하는 사용자 인터페이스를 제공한다.   
   
설계의 고려사항   
소프트웨어도 개발과 운용, 유지보수를 효과적으로 행하기 위해 구성 요소(모듈, 엔터티 등)들로 분할(partition)된다. 분할된 요소들은 서로 다른 기능을 수행하는 독립성을 가지고 있어야 한다.   
분할에서 추구하는 중요한 원칙 : 서로 연관되어 있는 부분들은 같은 구성요소에 있어야 하며, 서로 연관성이 없는 부분들은 연관성이 없는 구성요소들에 할당되어야 한다.   
   
응집도(cohesion)는 모듈 내부가 얼마나 단단히 뭉쳐져 있는가를 나타내는 성숙도의 측정치이다.   
결합도(coupling)는 모듈 사이의 상호 연관성의 복잡도를 일컫는다.   
이해도(understandability)는 다른 프로그램 요소나 정보를 참조하지 않고 이해할 수 있는 용이성이다. 시스템의 응집도가 높을수록 프로그램 요소들을 쉽게 이해할 수 있으며 고쳐나가기 쉽다.   
적응도(adaptability)는 새로운 환경에 적절히 대응할 수 있도록 소프트웨어를 변경시킬 수 있는 용이성이다. 환경과 연관된 부분을 지역화하여 이해도를 높이고 이식성(Portability)도 높여야 한다.   
   
13장 자료흐름 중심 설계와 DB 설계   
   
구조적 설계   
구조적 분석기법에서 사용하는 자료흐름도(DFD)에 기초한 요구사항 명세서를 바탕으로 구조적 설계에서 구조도표를 작성한다. 구조도표는 소프트웨어 시스템이 상호 유기적인 관계를 가지고 작용하는 기능들로 분할된 모습을 보여 준다. 구조 도표의 정보 흐름에는 입력값이 데이터인지, 제어인지에 따라 두가지 유형이 있다. 입력값이 데이터이면 변환흐름, 제어이면 트랜잭션 흐름으로 나뉜다. 다음은 각 정보 흐름을 프로그램 구조로 전환하는 가이드라인이다.   
자료 흐름의 유형은 입력값이 data냐 제어냐에 따라 두 가지 유형이 있다.   
일반적으로 시스템은 변환흐름이 지배적이며 일부 트랜잭션흐름을 가지고 있다.    
또한 일부 트랜잭션흐름의 동작 경로는 변환흐름의 특성을 가지며 다른 경로는 트랜잭션흐름 특성을 가질 수 있다.   
변환흐름(transform flow): 입력(input)을 받아들여 가공처리한 후 새로운 결과물(output)을 만들어 내는 프로세스를 들 수 있다. (입력 Data 가공 하여 출력).   
입력흐름, 변환중심, 출력흐름의 3가지 시스템으로 구성.   
1 단계: 요구사항 명세서로 부터 정제된 자료흐름도를 만든다.   
2 단계 : 자료흐름의 유형을 조사한다.   
3 단계: 입력경계와 출력경계를 정한다. 입력흐름, 변환중심, 출력흐름에 속한 버블들을 규명한다.   
4 단계 : 최상위 수준에서 자료흐름 중심 프로그램 구조 개발, 분할   
5 단계 : 자료흐름도를 프로그램 구조로 전환(두번째 수준의 세분화)   
6 단계 : 프로그램 구조의 정제: 모듈의 응집도가 올라가고 결합도가 최소화 되도록 변환   
   
   
트랜잭션흐름(transaction flow): 입력을 받아들여 입력값에 의해 결정을 내린 후 입력과 관계없는 결과물을 출력하는 경우이다. 프로세스는 주어진 입력에 의해 결정을 내리며 서로 다른 처리동작을 수행하여 출력물을 생성하는 것이다. (제어값에 의해 다양한 출력) 트랜잭션이란 자료나 제어 시그널 등이 어떠한 행위를 유발시키는 것을 말한다. (입력값 변환이 아님)   
1 단계: 요구사항 명세서로 부터 하나의 자료흐름도를 만든다.   
2 단계: 자료흐름도가 트랜잭션흐름을 갖는지 결정한다.   
3 단계: 트랜잭션 중심과 동작 경로(action path)를 파악한다.   
4 단계: 트랜잭션흐름 프로그램 구조 개발   
5단계: 자료흐름도를 프로그램 구조로 매핑   
6 단계: 프로그램 구조 정제   
   
14장 디자인패턴   
   
소프트웨어 디자인 패턴은 소프트웨어를 설계할 때 특정 상황에서 자주 사용하는 패턴을 정형화한 것이며, 좋은 소프트웨어 설계를 위한 개발자들의 경험적 산물이라 할 수 있다.    
특징1 : 경험을 통해 얻음   
특징2 : 특정한 형식을 갖고 체계적으로 작성되는 것이 일반적   
특징3 : 패턴에는 각기 다른 추상화 수준이 존재하며 계속적으로 진화함.   
장점1 : 의사소통에 도움을 준다.   
장점2 : 높은 완성도의 디자인을 빠른 시간에 만들어낼수 있다.   
장점3 : 재사용을 용이하게 한다.   
   
GoF의 패턴 분류 : Factory Method, Singleton, Adapter, Façade, Strategy   
Singleton: 오직하나의 인스턴스만을 만들어 관리하는 방법(객체생성)   
Façade: 하나의 인스턴스로 하위구조를 연결하기 위한 방법(객체구조)   
Strategy : 행위들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스들이 존재하는 경우, 각각의 서로 다른 행위 별로 클래스를 작성한다. 알고리즘의 변형이 필요한 경우에 사용할 수 있다. 다중 조건문을 사용해야 하는 경우 strategy 클래스로 만든다.   
Factory Method: 객체를 생성하기 위한 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 하위 클래스에서 이루어지도록 인스턴스 생성의 책임을 미룬다. 정확히 어떤 객체를 갖고 작업할지에 대해서는 런타임 시로 미룰 때 유용하다.   
Adapter: 적은 비용으로 기존의 라이브러리를 사용할 수 있는 방법을 제시하고 있는 패턴이다. 라이브러리를 수정하여 사용할 때 쉽게 해결할 수 있도록 함.   
   
디자인패턴의 필수 개념 : 다형성과 동적 바인딩   
다형성 : 같은 오퍼레이션이 다른 클래스에서 다르게 동작하는 것을 말하며, 하나의 함수 이름이나 연산자가 여러 목적으로 사용될 수 있는 것을 의미한다. 주로 상속 관계에서 사용되어 상위 클래스에 정의된 하나의 오퍼레이션에 대해 각 하위 클래스가 가지고 있는 고유한 방법으로 응답할 수 있도록 유연성을 제공한다. 다형성은 상위 클래스를 통하여 하위 클래스의 메소드를 호출할 수 있도록 하는 개념이다. 다형성을 통해 저마다의 기능을 가진 하위 클래스를 자유롭게 정의할 수 있으며, 새로운 하위 클래스가 기존 코드의 변경 없이 쉽게 추가될 수 있다. 공통적인 속성과 오퍼레이션을 상위 클래스에 정의하고 상속하게 함으로서 디자인과 코드의 중복성을 줄이고 객체지향의 장점을 극대화할 수 있다   
동적 바인딩 : 실행 시간(run time)에 하위 클래스의 객체를 통해 동작이 정해지는 것을 동적바인딩(run-time binding)이라 한다. 실행 시간(run time)에 객체의 타입에 따라서 자동적으로 하위 클래스의 적합한 동작이 결정된다.   
   
무분별한 패턴 사용으로 인해 유지보수가 어려운 소프트웨어가 만들어질 수도 있다.   
   
15장 사용자 인터페이스 설계   
   
시스템의 모든 사용자 인터페이스는 일관성을 가져야한다 그러나 큰 시스템 개발 시 여러 사람이 사용자 인터페이스를 설계, 구현하므로 일관성을 유지하기 어렵다. 일관성을 가지기 위해 개발 이전에 사용자 인터페이스에 대한 표준안을 만들어야 하며 개발 후에도 점검하여 오류를 수정하여야 한다.   
1.	인터페이스는 일관성 있게 설계되어야한다.   
2.	의미 있는 피드백을 제공하여야 한다.   
3.	파괴적인 행동을 하는 경우 이를 다시 확인해야한다(삭제시, 확인 후 휴지통)   
4.	사용자가 취한 대부분의 행동에 대하여 원상태로 돌아갈 수 있도록 허용하라.   
5.	행동들 사이에 기억해야 할 정보의 양을 줄여라   
6.	대화, 움직임, 생각의 효율성을 추구하므로 키 입력을 최소화하고 마우스가 움직일 거리도 화면 설계에 맞추어 최소화한다.   
7.	실수에 관대하라   
8.	기능에 따라 활동을 분할하고 화면을 배치하라. 명령어와 활동들을 분류하여 배치해 응집력이 있도록 한다.   
9.	도움말 기능을 제공하라   
10.	간단한 동사와 명령어를 사용하라   
11.	불필요한 입력은 제외시켜라   


## 7. 학습 내용에 대한 개인적인 총평
+ 암기할 내용이 많아 힘들었다.
+ 코드검사, 유지보수, 테스트 부분은 생략하였다.
+ 42에서 구현 단계의 대한 경험이 쌓이고 있다.
+ 3회독은 하고 시험봐야겠다.
+ 화이팅!

## 8. 다음 학습 계획
+ 소프트웨어공학 품질,비용,시간,일정,형상 관리 학습