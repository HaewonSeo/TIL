## 1. 학습 날짜
+ 2020-10-28(수)

## 2. 학습시간
+ 17:00 ~ 19:00 (자가)   
+ 20:00 ~ 22:00 (자가)
+ 총 학습시간 : 4시간

## 3. 학습 범위 및 주제
+ 컴퓨터구조

## 4. 동료 학습 방법

## 5. 학습 목표
+ super pipeline/super scalar 학습
+ multithreading 학습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 컴퓨터구조 강의 수강 : 2시간

#### **Super pipeline/Super Scalar**

+ super pipeline : 자를수만 있다면, 균일하게(균일하지 않으면, cycle time이 길어진다. clock frequency가 가장 긴 stage에 바운드된다.) 더 잘게 잘라보자. stage의 길이가 짧아지기 때문에 clock frequency를 높일 수 있다. (delay time이 줄어들기 때문에) -> 성능 높아짐. 
자를 수 있는 한계가 존재한다.

+ super scalar : 자르는게 아니라 두개씩 처리하면 되지 않겠느냐, 그렇다고 성능이 완전히 2배가 되지는 않는다. 수퍼스케일라 자체로써는 그렇게 좋아지지는 않는다.(멀티 쓰레드가 추가되어야 좋아진다.)


+ 수퍼파이프라인 :
(1)5단계가 10단계로 늘어난다. 즉, forwarding path가 늘어난다. 
(2)load 명령어의 경우 1clock stall이 2clock stall이된다.
(3)ALU가 반으로 잘린 경우, 뒤의 명령어가 앞의 명령어의 결과를 필요로하는데, 아직 앞의 명령어의 결과가 나오지 않아 stall이 발생하게 되버린다. 이런 경우 자를 수가 없다. uneven balance
--> 수퍼파이프라인으로 인한 성능향상이 어느수준 이상은 어렵다.

--> 그래서 수퍼스케일라를 생각하게 되었다.

+ VLIW는 수퍼스케일라와 비슷한데, 더 옛날것
+ VLIW : 한가지 명령어에 대해 여러 데이터 연산을 동시에 수행
+ 수퍼스케일라 : 여러 명령어에 대해 동시에 수행

+ 수퍼스케일라의 문제 : 문제들이 파이프라인 스테이지별로 있는게 아니라. 같이 들어오는 명령어끼리 발생하게 되었다. 세가지 문제가 더 가중된다.
이게 과연 좋은 방법인가?
--> 멀티 쓰레딩 이후 결과가 나온다.

+ 스퍼스케일라를 좀더 잘쓰기 위한 방법 : OoO(명령어 순서를 뒤바꾸겠다)

+ 명령어를 fetch한다. : 메모리에서 명령어를 가져오는 시점/행위를 의미한다.
+ 명령어를 issue 한다. : 명령어를 ALU에 집어넣는 시점/행위를 의미한다.
+ completion : ALU에서 연산이 끝나는 시점/행위를 의미한다.
+ commit : register file에 data를 write back하는 시점/행위를 한다.

+ in-order : 순서대로
+ out-of-order :  순서를 뒤짚어서

+ OoO(Out of Order)의 의미? 
+ 순서를 바꾸어서 number of clock cycles을 줄일 수가 있다.

+ (page11) I2 : needs a execute cycle.

+ cpu가 명령어들을 분석해서 순서를 바꾼다. 그러나 계산결과는 bad 

+ ###중요###(page18) 3가지 dependency : MIPS에서는 일어나지 않지만, 지금 세가지 명령어를 동시에 처리한다고 했을 때, 순서가 바뀌면 결과도 바뀌는 문제가 발생

+ dependency issue에 대한 해결책 -> Register renaming
+ 뒤짚었을 때 dependency issue가 있을 register(R3)에 대해서 R3b,R3c와 같이 이름을 주는 것
+ register renaming은 true dependency issue는 해결하지 못한다.
+ true dependency issue가 발생할 register를 제외하고 순서를 바꾸어 결과에 문제도 없으면서, 성능도 높인다.

+ data dependency issue(data harard)는 해결되었다.
+ 이제 남은 control hazard와 structural hazard는?
--> cpu의 multi threading 기술이 위의 2개의 hazard에 대해 간접적(직접적은 아님)으로 도움을 준다.

---------------------------------------------------
#### **MultiThreading**

+ thread : 명령어의 흐름(상태를 가진), 하나의 독립된 프로그램

+ 어떻게 한개의 cpu에서 다중의 쓰레드를 돌릴것인가?

+ 결과적으로 멀티쓰레드로 hazard들을 모두 해결하고, 성능 증가의 핵심이 된다.

+ 최근 AMD가 인텔보다 가성비가 좋은 cpu를 만들게 된 이유가 AMD의 멀티쓰레드 기술의 발전 때문이다.

+ thread warping(in GPU. not in CPU) : 한 thread가 어디서 정체되면 휴지기처럼 보내버리고, 다른 thread를 실행한다. 사용자입장에서는 2개의 쓰레드가 동시에 돌아가는 듯한 느낌. 시간차를 이용해서 성능을 높이는. 이러한 아키텍쳐를 single instruction multithreading (sint)라는 기술이라 부름. 

+ 멀티쓰레딩을 잘하려면, 중간에 노는 시간을 다른 쓰레드로 채우는 것을 해야 함.

+ cpu자체를 멀티쓰레드 친화적으로 만들면, context switching 하는 시간을 줄일 수 있어서 시스템의 성능이 좋아진다.

+ 싱글 쓰레드의 성능을 낮출 수 있다. : A를 하다가 오래걸려서 그 사이에 B를 하는데 B를 하느랴고 A가 끝났다는 응답을 늦게 받는다.

+ Fine-grained 
+ 여러 쓰레드가 있는데, 매클락마다 쓰레드를 바꾸는 것임.
+ 쓰레드 한개 단위에서는 성능이 저조하다.
+ 한 쓰레드가 논다고 해서 다른 쓰레드가 노는 것은 아니다. -> system-wise 성능은 증가
+ data/control hazard를 해결한다. -> bubble도 사라짐

+ 단점
+ ###중요###
+ 정확히는 1/N로 내려가지는 않는다. 1/N보다는 덜 내려간다.
+ 그 이유
+ 1. 한 쓰레드가 200cycle논다고 해서, 1000cycle이 노는게 아니기 때문이다.
+ 2. dependency checking과 branch prediction에서 발생하는 버블이 사라졌기 때문에 
+ 그러나 전반적으로 1/N처럼 내려가는 것으로 보인다.

+ ##중요##
+ 자원 집중이 증가 : 노는 쓰레드가 없어지고, 많이 사용하게 되었다. 소수의 하드웨어를 다중의 쓰레드들이 사용하려고 하는 확률이 높아진다. 즉, structure hazard의 확률은 증가할 수 있다.

+ 쓰레드간의 dependency를 체크해야 함

+ (수퍼 스케일라의 경우) 쓰레드 내의 여러 명령어들간의 디펜던시 체크, 브랜치 예측도 여천히 남아있는 문제.

+ (page10) 128개의 쓰레드, 150cycle동안 지연되어도 1번 노는 정도밖에 안된다.

+ Coares-grained
+ fine은 자잘한것, coares는 큼직한것
+ 큰 지연이 발생하면, 그때만 쓰레드를 바꾸고, 자잘자잘한 때는 바꾸지 않는다.

+ fine은 coares에 비해 구현이 쉽다.(매클락마다 바꾸는 정규화니까, 또 dependency checking과 branch prediction안해도 되니까(수퍼스케일라에서는 해야 하긴함))
+ 그러나 coares는 큰 이벤트 발생 전까지 한 쓰레드 안에서 연산하니까 위 2가지를 해야한다.
+ fine은 pc값과 레지스터 파일을 가지고 있다.
+ 멀티쓰레드 친화적 - pc값 여러개, 레지스터도 여러개 가지고 있는 환경.
+ coarse는 큰 이벤트 발생시 쓰레드 컨텍스 스위칭. 스택에 pc값과 레지스터를 올리고, 새로운 pc값과 레지스터 파일을 올리고 동작시키기 때문에. 오버헤드가 있다.

+ fine은 단일 스레드 성능이 낮다. 이 중에서도 우선순위가 높은 쓰레드가 늦게 처리된다는 문제 발생!
+ 사용자 입장에서는 coarse가 낫다. 우선순위가 높은 쓰레드가 먼저 처리되니까 (체감성능상)

    

## 7. 학습 내용에 대한 개인적인 총평
+ 컴퓨터구조 강의를 들으면서, 진로에 대한 고민을 하게 되었다. 내가 가야할 분야는 무엇인지. 시스템 소프트웨어 엔지니어인지, 아니면 다른 분야를 선택할지에 대한 고민이 깊어지는 나날이다. 지금까지 학부에서 배운 내용은 주로 임베디드 관련이고, 흥미도 있다. 그러나, 내가 아직 경험해보지 못한 다른 분야(안드로이드, ios 등..)에 대한 지식은 무지하다. 그렇다고, 그 분야들을 배제해야 할 것인가. 그 분야들을 배제하고, 임베디드에 집중할 것인가. 아니면 경험해보지 못한 분야까지 경험하고 나서야 진로를 정할 것인가. 그에 대한 고민이 깊다. 물론, 내가 공부한 것이 깊어봤자 얼마나 깊을 것이고, 실무에서 어떻게 쓰일지도 자세하게 알지는 못하나, 취준의 시기에서 선택이 필요하고, 결정을 내려야 할 시기가 왔다는 것이다. 그리고 나는 42에서 무엇을 목표로 해야 할 것인가. 

## 8. 다음 학습 계획
+ 데이터베이스 설계 관련 강의 수강 및 복습
