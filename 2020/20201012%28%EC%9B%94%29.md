## 1. 학습 날짜
+ 2020-10-12(월)

## 2. 학습시간
+ 15:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습 시간 : 8시간

## 3. 학습 범위 및 주제
+ 알고리즘(Dynamic Programming)

## 4. 동료 학습 방법

## 5. 학습 목표
+ Dynamic Programming 예제 실습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 8시간    
    
### 최단경로 문제 

#### Brute-force algorithm(무작정 알고리즘)
+ n개의 정점의 모든 경로 : (n-2)!, exponential => 비효율적인 알고리즘

#### Floyd Shortest Path
+ 동적계획식 전략
    - 재귀관계식 성립
    - bottom-up
```python
from utility import *

def allShortestPath(g,n):
	# node number는 1부터 n
	P = [[0 for cols in range(n)] for rows in range(n)]
	# copy g to D
	D = g[:]

	for k in range(n):
		for i in range(n):
			for j in range(n):
				# Floyd Alg2
				if D[i][k]+D[k][j] < D[i][j]:
					P[i][j] = k + 1 			#vertex는 1부터 시작.
					D[i][j] = D[i][k]+D[k][j]
	return D, P

# 중간 노드 출력
def _path(p, q, r):
	if p[q][r] != 0:
		_path(p, q, p[q][r] - 1) # index = (행렬 P 내부의 값) - 1
		print("v%d" %p[q][r], end=" ") # 경유한 정점을 출력
		_path(p, p[q][r] - 1, r)

# wrapper 함수 : 시작노드, 끝노드 출력기능만 수행
def path(p, q, r):
    print("v%d"% q, end=" ")
    _path(p, q - 1, r - 1)		# path에서 index가 0부터 시작하므로 -1 하였다.
    print("v%d"% r, end=" ")



# 중간 vertex만을 출력
def path2(p, q, r):
	if p[q-1][r-1] != 0:					#P는 인덱스 0부터 시작하고, 정점은 1부터 시작한다.
		path2(p, q, p[q-1][r-1])
		print("v%d" %p[q-1][r-1], end=" ")	#경유한 정점을 출력
		path2(p, p[q-1][r-1], r)


inf=1000
g=[[0,1,inf, 1,5],
   [9,0,3,2,inf],
   [inf,inf,0,4,inf],
   [inf,inf,2,0,3],
   [3,inf,inf,inf,0]]
d, p = allShortestPath(g,5)
print("\nmatrix d")
printMatrix(d)
print("\nmatrix p")
printMatrix(p)

print("\npth")
path(p, 5, 3)
print()
path2(p, 5, 3)
```
+ 시간복잡도 : n^3. 무작정 알고리즘보다 효율적이다.
+ 공간복잡도 : 단 하나의 D 행렬만 필요하다. 
+ 재귀적관계에 대한 이해
    + D^k[i][j] : v1~vk의 정점만을 이용해서, vi에서 vj로 가는 최단경로의 길이
    + **거쳐가는 노드**를 기준으로 D를 갱신한다.
    + D^k로 이해하기 보다는 거쳐가는 노드를 바꿔가면서 최단경로를 비교하여 구한다고 생각하는 것이 이해하기가 쉬운 것 같다.
+ k를 오름차순이 아닌 내림차순으로 반복문을 수행한 결과
    + D의 결과는 같았다. -> 노드번호의 대소는 중요하지 않다
    + P의 결과는 달랐다. -> ???
    + 근데, 최단 경로인 path는 같았다. -> ??????? 
        + index는 0부터 시작하고, 그림 상 노드는 1부터 시작하는 차이에서 오는 혼란이 막대했다.
        + 다음부터는 무조건 일치시키고 보자
        + P행렬 안에서도 path를 출력할 때 사용되는 행렬값은 동일했다.
        + 새벽에 이 문제에 대한 원인을 찾았다.(아래내용)
```
# for k in range(n-1, -1, -1):
# 위처럼 k를 오름차순이 아닌 내림차순으로 했을 경우 D의 결과는 같은데, P의 결과가 다르다.
# 그 이유는 i부터 j까지의 경로 중간에 노드를 2 개 거쳐갈 경우
# 반복문 안에서 앞서 나오는 노드가 늦게 나온 노드로 덮여쓰여지기 때문이다.
```
        
## 7. 학습 내용에 대한 개인적인 총평
+ 알고리즘 풀이에 대한 회의감? 허탈함? 그런 감정을 느낀 하루이다. 오늘 최단경로문제만을 가지고 하루종일 붙잡고 있었던 것 같다. 사실 이 문제는 내가 푼 다른 문제들에 비해 단순하고, 코드 길이도 짧다. 구글에 풀이나 교수님 강의에서도 쉬운 알고리즘이라 할만큼 간단하다고 하는 문제이다. 그런데 내 머리로는 당최 이해되지 않는 풀이였다. 하루종일 뚫어져라 쳐다봐도 이해가 안되고, 머리가 나쁜건지, 집중을 못하는 건지.. 고민하다보니 쉽다 하는 문제를 이해 못하는 나를 자책하고, 화가 나기도 했다. 알고리즘을 풀고 어제 계획한 다른 공부를 이어 해야하는데, 이 문제가 안풀리니.. 시간만 하염없이 흘러가고, 그렇다고 포기하자니, 망할 자존심?고집? 때문에 손에서 놓지도 못했다. 
+ 누군가 해결책을 떠먹여 주기를 바라는 마음에 슬랙에 지금 나의 상황에 대해 토로하려 하다, 과거 슬랙에서 이러한 상황에 대한 고민글을 본 경험이 떠올라 쓰던 글을 지웠다. 현재 상황에 대해 투덜대는 감정이 지배적인지라, 슬랙에 물어본들 도움이 되지 않을 것 같아, 구글을 키고, 검색했다..
+ "알고리즘 풀다.." 나와 같은 상황에 대한 글이 많아 처음에는 놀라웠지만, 지금 생각해보니 당연한 것 같기도 하다. 알고리즘을 나 빼고 모두 잘 풀면, 그게 말이나 되는 소리인가.. 몇 개 글을 읽고 나니 분한 마음이 조금 가라앉았다. 그리고 이 글을 쓰면서 안정을 되찾고 있다. 
+ 그래서 결론은? ~~모르겠다.~~   아니, 이제는 고집부리며 몇시간씩 붙잡고 있기보다는, 일정 시간을 두고 반복해서 보아야겠다. 고집부리며 본다고 풀리지도 않고, 오히려 감정 소모만 심해지는 것 같다.
+ 그래도 한가지 좋은 것이 있다면, 오기가 생긴다. 알고리즘 잘하고 싶다. 이것도 일종의 승부욕인 건가 싶기도 하다. 
+ 마음에 안정을 찾은 글을 남기고 이제 그만, 푸념은 마무리하고 다른 공부하려 한다.
<http://wookje.dance/2019/04/16/how-to-study-algorithm/>

## 8. 다음 학습 계획
+ SQL 데이터 조작어 강의 수강 및 실습