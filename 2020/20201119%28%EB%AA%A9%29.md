## 1. 학습 날짜
+ 2020-11-19(목)

## 2. 학습시간
+ 15:00 ~ 18:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 7시간

## 3. 학습 범위 및 주제
+ DB 정규화

## 4. 동료 학습 방법

## 5. 학습 목표
+ DB 정규화 학습 및 실습 


## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ DB 강의 수강 : 4시간    

    
#### 7. 릴레이션 정규화  
<7.1 정규화 개요>   
   
정보의 중복을 최소화하고 갱신이상을 막기 위해 정규화를 한다. 정보의 중복이 있는 경우에는 갱신이상이 발생할 수 있다.   
물음에 대한 이론적인 해답 : 정규화   
   
- 갱신 이상   
1. 수정이상   
2. 삽입이상   
3. 삭제이상   
   
(5 page) 이 설계의 문제   
1. 회사정책이 바뀌어 사원이 3개이상의 부서에 소속한다고 하면, 애트리뷰트가 새로 추가되거나, 새로운 릴레이션을 만들어야 한다.    
2. 또한, 사원의 소속부서가 최대부서수보다 작으면 정보에 null이 들어가 메모리의 낭비 발생   
   
(6page) 이 설계의 문제   
1. 정보의 중복 -> 저장공간이 낭비된다.   
사원에 대한 정보들이 중복되어 있다.   
또한, 부서이름/부서번호 또한 중복되어 있다.   
   
2. 수정 이상   
박영권에 대해서만 개발을 연구개발로 변경하고, 다른 레코드에 대한 수정을 잊어버리면, 레코드마다의 정보 불일치가 발생한다.   
   
3. 삽입 이상   
4. 삭제 이상   
만약 김창섭 레코드를 삭제하게 되면, 1번 부서인 영업부에 대한 부서 정보가 사라지게 된다.   
   
--> 이러한 갱신이상 문제는 릴레이션 분해로 해결가능하다.   
   
- 릴레이션 분해   
   
- 정규형의 종류   
제1정규형(first normal form), 제2정규형(second normal form), 제3정규형(third normal form), BCNF(Boyce-Codd normal form),   
제4정규형(fourth normal form), 제5정규형(fifth normal form)   
   
- 관계 데이터베이스 설계의 비공식적인 지침(경혐적인)   
지침1 : 서로 다른 엔티티에 속하는 애트리뷰트들을 하나의 릴레이션으로 만들지 말라.   
여러 엔티티에 속하는 애트리뷰트를 하나의 릴레이션 스키마에 포함시키면, 정보의 중복이 발생하고, 갱신이상이 야기된다.   
그림은 학생과 학과 엔티티에 속한 애트리뷰트들을 하나의 릴레이션에 포함시킨 나쁜 사례이다.   
지침2 : 널값은 저장공간을 낭비하고, 정보해석이 어렵기 때문에 값이 널일 가능성이 높은 애트리뷰트를 가능한 릴레이션에 포함시키지 않아야 한다.    
지침3 : 기본키 또는 외래키로 사용되는 애트리뷰트 간의 동등조건으로 조인할 수 있도록 릴레이션을 설계해야 한다.   
지침4 : 여러가지 갱신이상을 피하기 위해 개념적 설계단계에서 고려한 것보다 더 완전하게 무결성제약 조건들을 고려해야 함으로써 설계를 정제해야 한다.   
   
   
<7.2 함수적 종속성>   
   
- 결정자(determinant)   
   
- 함수적 종속성   
예: 직책은 (사원번호, 부서번호)에 함수적으로 종속하지, 사원번호에 함수적으로 종속하지는 않음   
사원번호는 직책을 고유하게 결정할 수 없으나, 사원번호와 부서번호가 직책을 고유하게 결정할 수 있다.   
1324의 사원번호가 개발에서는 프로그래미어지만, 홍보에서는 웹디자이너이다.   
   
- 완전 함수적 종속성 & 부분 함수적 종속성   
fd3은 완전함수적 종속성을 나타낸다. 사원번호와 부서번호가 직책을 결정하는데, 이 중 하나만으로는 직책을 결정할 수 없기 때문이다.   
(사원번호.부서번호)가 부서이름을 결정하는 것은 부분함수적 종속성이다. 왜냐하면, 이의 진부분집합인 부서번호만으로도 부서이름을 결정할 수 있기 때문이다.   
참고로 (부서번호)가 부서이름을 결정하는 것은 완전함수적 종속성이다.   
   
- 이행적 함수적 종속성   
학번이 학과전화번호를 결정하는 것은 이행적 종속성이다.   
왜냐하면, 학번이 학과이름을 결정하고, 학과이름이 학과전화번호를 결정하기 때문이다.   
   
<7.3 릴레이션 분해>   
   
- 무손실 분해   
   
(page29) 수강1, 수강2를 자연조인하면, 원래 수강테이블에 없던 튜플이 생성된다. -> 가짜 튜플   
따라서 이분해는 무손실 분해가 아니다.   
   
릴레이션 분해 중 필요한 분해(중복을 제거하는 분해), 불필요한 분해(중복이 없는데 분해해서 다시 조인시 중복을 만듦), 나쁜 분해(손실이 발생하는 분해) 가 있다.   
정보의 손실이라는 것은 원래 있던 정보를 잃어버리는 것 뿐만 아니라, 없는 정보(가짜정보)가 생기는 것도 손실이라고 이야기한다.   
   
Q. 분해시 테이블 att선정에는 함수적 종속성은 반드시 필요한 기준인가요??   
A. 다음 수업시간에 함수적 종속성을 이용해서 어떻게 분해할지, 분해된 테이블에 어떤 애트리뷰트가 들어가는지를 배운다.   
   
Q. 중간프로젝트에 설계배경 설계목표를 초기계획에서 수정해서 작성해도 되나요   
A. 수행하다가 변경내용은 변경사유와 함께 변경내용을 작성하면 된다.   
   
----------------------------------------------------------------------   
  
<7.4 정규형>   
실세계에서 많이 사용하는것은 BCNF까지 이다.   
   
- 제1정규형   
과목번호가 원자값을 가지지 않기 때문에 제1정규형을 만족하지 않는다.   
반복그룹(값이 집합형태로 나타나는 것)을 제거   
   
- 제2정규형   
키가 아니면서 다른 애트리뷰트를 결정하는 애트리뷰트를 새로운 릴레이션에 속하도록 하고, 이 릴레이션의 기본키가 된다. 이 기본키를 외래키로 학생2에 포함시킨다.   
부분 함수적 종속성을 제거한다.   
   
- 제3정규형   
이행적 함수적 종속성을 제거한다.   
   
- BCNF   
후보키가 아닌 결정자를 제거   
이 릴레이션의 후보 키는 (학번, 과목)과 (학번, 강사) 라는 것을 주목   
제3정규화에서 데이터베이스-이영준이 중복되던 것이 BCNF에서는 제거되었다.   
   
주요 애트리뷰트 & 비주요 애트리뷰트   
   
Q. 키는 외래키도 포함하는게 맞나요?   
A. 아니다. 앞에서 키가 아닌 애트리뷰트와 같이 이야기를 할때 외래키는 포함되지 않는다.   
   
Q. 정규화과정은 필수적으로 해야하나요?   
A. 예. 갱신이상이 발생하기 때문이다.   
보통 제3정규형 BCNF까지는 정규화과정을 필수로 하는 것이 일반적이다.   
제4,제5정규화에서 제1정규화을 하다보면 또다른 문제가 발생할 수 있어서, 그런 경우 trade-off를 해야한다.   
   
<7.5 역정규화>   
   
역정규화의 필요성 : 성능 향상, 불필요한 조인이 늘어나는 것을 방지하기 위해서.   
   
- CLOSURE   
R(A,B,C,D)을   
R1(A,B,C) , R2(A,D)로 분해. R은 AB->C, C->D, D->A의 함수적 종속성을 갖는다. 추가로 여기는 암시적으로 C->A라는 함수적 종속성이 있는 것이다.   
여기서 R1을 추가적으로 두 릴레이션으로 분해하려면 , R1의 함수적 종속성을 알고 있어야 한다.   
R1의 함수적 종속성 : AB->C, C->A   
R2의 함수적 종속성 : D->A   
   
projection : 원래 릴레이션에서 가지고 있는 함수적 종속성을 분해된 릴레이션으로 투영하여 각 분해된 릴레이션의 함수적 종속성을 찾아내는 것   
함수적 종속성의 closure : 원래 릴레이션에 존재하는 모든 함수적 종속성을 포함하는 것.   
Y의 closure : Y^+로 표시, Y가 결정하는 모든 애트리뷰트들을 포함하는 집합을 closure라고 한다.   
   
모든 Closure은 자기가 자신을 결정한다는 함수적 종속성을 가진다.(명백한 RULE) A->A, B->B, C->C   
   
(예제)   
ABC 3개의 애트리뷰트가 있고, A->B, B->C   
   
A+ = ABC(A->A, A->B, B->C)   
B+ = BC(B->B, B->C)   
C+ = C(C->C)   
   
AB+ = ABC   
BC+ = BC(BC->BC, B->C이외에 다른 부분 애트리뷰트가 결정하는 사항이 없기 때문에 추가적인 함수적종속성이 없다)   
CA+ = ABC    
   
ABC+ = ABC   
   
AB+와 CA+는 구할 필요가 없다. WHY?   
A+는 ABC 모든 애트리뷰트를 다 포함하고 있다. A+ 에 추가로 애트리뷰트를 포함한다고 하더라도 이미 A+가 모든 애트리뷰트를 결정하고 있기 때문에 당연히 모든 애트리뷰트를 결정하게 된다. 이미 계산이 되어 있다고 한 것은 이미 구해져 있다는 말이다.   
   
Q. closure를 구하는 방법은 프로젝션을 하는과정이라 볼수있는건가요?   
A. NO. closure를 다 구해놓고 릴레이션을 분해하고, 릴레이션을 분해한 쪽으로 프로젝션하는 것이다. 클로저는 프로젝션의 전단계이다.   
   
Q. CA+는 ABC에서 그러면 초기값이 ABC인건가요?   
A. 음.. 알고리즘의 다른 PATH라고 생각하면 된다.   
   
Q. 만약 A+ 에서 ABC 전부 나왔다면 다음 단계를 진행하지 않아도 되지 않나요?   
A. 맞다. A를 포함하는 다른 CLOSURE들에 대해서는 계산하지 않고, A의 CLOSURE를 활용할 수 있다. 이처럼 이전단계에서 계산한 closure를 활용할 수 있다.   
   
(CLOSURE 연습문제)   
ABCD 4개의 애트리뷰트가 있고,   
AB->C, C->D. D->A   
   
A+ = A(A->A)   
B+ = B(B->B)   
C+ = CDA(C->C, C->D, D->A)   
D+ = DA(D->D, D->A)   
   
AB+ = ABCD(AB->AB, AB->C, C->D, D->A, A->A, B->B)   
BC+ = ABCD(BC->BC, B->B, C->CDA)   
CD+ = ACD(CD->CD, C->CDA, D->DA)   
AC+ = ACD(AC->AC, A->A, C->CDA)   
AD+ = AD(AD->AD, A->A, D->DA)   
BD+ = ABD(BD->BD, B->B, D->DA)   
   
ABC+ = ABCD(AB->ABCD)   
BCD+ = ABCD(BC->ABCD)   
ACD+ = ACD(ACD->ACD, 이 외의 부분집합도 B를 결정하지 않는다. 따라서 ACD)   
ABC+ = ABCD(AB->ABCD)   
   
ABCD+ = ABCD(ABC->ABCD)   
   
이렇게 closure를 구해서 나중에 릴레이션을 분해했을 때, 분해된 릴레이션의 closure들을 구한것을 전부다 projection시키면 분해된 릴레이션의 함수적 종속성을 알아낼 수 있다.   

## 7. 학습 내용에 대한 개인적인 총평
+ 실습을 진행하였는데, 4번의 시도 끝에 통과했다.. 
+ 정규화 내용은 정말 알다가도 모르겠다.
+ 오늘 못 푼 무손실 분해에 관한 문제는 다음 수업시간에 학습할 예정이다.
+ 학습한 내용이 누적되어 쌓이다 보니 알던 내용도 헷갈리게 되는 것 같다.
+ 이제 슬슬 잠을 줄여서 학습량을 늘려야 할 때가 된 것 같다.

## 8. 다음 학습 계획
+ 소프트웨어공학 테스트, 유지보수 학습