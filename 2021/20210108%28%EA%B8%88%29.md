## 1. 학습 날짜
+ 2021-01-08(금)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ 선형대수
+ netwhat

## 4. 동료 학습 방법


## 5. 학습 목표
+ 선형대수 강의 수강 및 문제 풀이
+ 네트워크 학습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 선형대수 강의 수강 :  1시간 
    
### 선형대수
6.5.3 그램-슈미트 과정과 분해

### netwhat
`Simple Protocol, Stop and Wait, Go-back-N, Selective Repeat Protocol 로 발전한 DLC 기술이, 이전기술 대비 어떤 문제점을 개선할 것인지 간략하게 설명하시오.`   
   
- The data link control (DLC)   
데이터 링크계층은 물리적 전송 매체에 의해 일대일로 직접 연결된 호스트 사이의 오류 제어와 흐름 제어 기능을 제공한다. 송신 호스트에서 전송한 프레임은 점대점으로 직접 연결된 수신 호스트에 라우팅 과정없이 전달된다.   
   
- Simple Protocol : 2계층의 센딩 노드에서 리시빙 노드로 이동. 헤더와 테일을 붙이고, bit stuffing 작업을 하고, 역방향 한다. 심플은 보내면 에러 없이 간다. 그러나 말도 안 된다. 네트워크에서 받아서 framing해서 리시버 노드가 받고 네트워크 레이어로 올림.   
에러는 반드시 날 수 밖에 없다.   
   
- Stop and Wait : 센더가 보내고 스탑, 상대방이 잘 받았다고 응답할 때까지, CRC 16비트를 다 더해서 에러가 있는지를 판단. 받았을 경우 에러가 없다면 ack를 돌려보내고 네트워크 레이어로 올림, timer. ack 오지 않은 채 timer 시간이 지나면 재전송함(복구가 가능), 속도가 느리다. 알로하일때처럼 보내는 메시지가 적기 때문, 오히려 안정적, 나름 쓸만함.    
ack가 오는 과정에서 에러가 발생하여 수신기가 프레임을 두 번 전송받게 되는 일이 발생하게 됨.> 헤더에 번호를 붙이기 시작, 헤더는 1비트면 된다. 수신 호스트는 받은 프레임의 다음 번호를 보냄.   
윈도우의 크기가 1이라서 전송효율이 극단적으로 떨어짐   
   
- Go-back-N : 스탑웨잇과 다른 특징-상대방에게 ack를 받지 않아도 0~14까지의 15개는 받지 않아도 쏘기 때문에 성능이 좋아짐. 센더 부분이 조금 복잡해짐 2^n-1까지는 상대방으로부터 ack를 받지 않고 보냄(send winndow sliding ) : 수신 호스트는 송신한 정보프레임을 자신의 내부 버퍼에 유지하는 데 이를 송신 윈도우라고함. 수신 호스트는 수신한 정보 프레임을 보관하기 위해 내부 버퍼인 수신 윈도우를 유지한다.  >>성능이 기하급수적으로 좋아짐 한번도착하면 메모리에 저장되어잇는지라 더이상 복사하지 않는다. 메모리를 copy 할필요가없다. 포인터로 인해서. 동적할당해서,, linked list 가져야 함.    
반드시 2^(n-1)만큼은 윈도우 사이즈를 구축해야 함.   
에러가 발생하면 다시 뒤로 백해서 다시 전송한다.   
개선점 : 이제는 백해서 에러 난 것만 보내자. 그 이후 것은 보내지 말고.   
여기서의 문제점 ? 수신호스트가 올바르게 수신한 정보 프레임도 오류로 처리해 재전송한다.   
   
- Selective Repeat Protocol : 선택적 재전송, 오류가 발생한 프레임만 선택적으로 복구하는 방식 ,수신단도 메세지를 하나가 아닌 여러개로 받을 수 있도록 커지고, 상대방에게 응답을 받지 않고 보낼 수 있는 개수인 2^(n-1)만 보낸다. 보내는 쪽은 개수의 변화밖에 없다. 많이 바뀌는 건 수신단. 메시지를 여러 개 받을 수 있으며 메시지가 잘 온 건 저장, 잘 오지 않은 것은 재복구를 위해 듬성듬성 저장하는 구조. 리시브 윈도우들을 가지고 있는 버퍼들을 만들게 되었다.   
송신이 에러없이 되면 그 번호의 버퍼를 지우고 센딩 윈도우가 이동한다.    
메시지별 타이머가 동작한다. NAK(번호는 에러번호)보내면 재전송한다. full-duplex도 가능.   
송신속도가 빠르다면 많이 보낼 수 있기 때문에 수신단의 버퍼의 크기를 크게 잡아준다.    
너무 많이 잡아주면 컴퓨터 맛탱이, 적으면 송신속도는 빠르지만 처리 속도는 느리다.   
nak(negative,(non)-ack) : 에러가 났으니 다시보내라   
메세지별 타이머가 동작하는 게 하이라이트   
타이머는 보내는 데이터의 개수만큼 존재.   
   
데이터 링크 레이어는 인접한 거리에서 메시지 전달할 때 그 사이의 에러와 플로우 컨트롤하는 제어하는 것이고, TCP는 서버와 웹 사이에서 멀리 떨어진 사이에서 에러와 플로우 컨트롤하는 것에서 비슷하다. 4계층도 거의 똑같이 동작한다.   
두 번 하는 이유 : 중간 장치들에서도 메시지가 유실될 수 있기 때문.   
   
`Selective Repeat 방식에서 송신단의 메시지 전송에서 발생하는 에러를 어떻게 복구하는지, 간단하게 설명하시오.`   
   
 제대로 송신이 되면 수신단도 메시지를 여러 개 받는다. 버퍼들을 가지고 있어 저장하고 잘 오지 않은 것은 재복구하기 위해 듬성듬성 구성하게 된다. 만약, 송신 과정에서 에러가 발생하면 수신단은 송신단에게 에러가 난 메시지 번호 NAK(non-ack)를 보낸다. 그러면 재송신이 일어난다. 메시지를 받으면 수신단에서도 슬라이딩 윈도우가 이동함. 나중의 메시지를 앞의 메시지가 오기 전에는 네트워크 레이어로 올리지는 않는다. 앞의 것이 없기 때문에. NAK 가는 동안 다른 메시지 수신함. 앞의 메시지인 1번 을받으면 1,2,3을 처리해서 네트워크 레이어로 올리게 됨. 메시지별 타이머가 동작, 메시지별 타이머가 존재. 타이머가 터지면 그 때도 재전송 가능.   
 
`DLC 기술에서는 다량의 timer를 사용하는데, 이 타이머들을 실제 소프트웨어에서 구현하는 방식을 수업 시간에 다루어진 내용 중심으로 설명해 보시오.`   
   
정말 많은 타이머가 필요하다. 타이머의 개수와 상관없이 구현할 수 있는 방법. 타이머를 여러 개 띄운다는 것은 메모리를 여러개 띄운다는 것. 띄울수록 메모리를 잡아먹는 것이다. 전자과 interrupt.   
폴링 방식으로 구현한다. 폴링 방식 : 할말있니? 있다면 이야기 해봐 .프로그램에서 이벤트를 받을 때마다 끌려다니면 죽으니깐 이벤트와 상관없이 일정 시간마다(10ms) 딱 하나 띄운다. 하나가 뜨면 1.메시지 버퍼에 수신한게 있나? 있으면 처리하자. 2. 타이머 10ms 시간 지났으니 증가시키자. 터지면 터지는 작업 시켜. 일정 시간 단위마다 살아나서 큐를 보고 받은 게 있으면 처리한다. 이벤트 큐/메시지 큐, 본인이 일정 시간마다 살아나서 처리하고, 타이머는 정수들이기 때문에 시간 지났으니 증가시킴.   
   
    
   
`DLC 기술과 같은 통신 프로토콜은 대량의 메시지를 상하위 계층에서 받고 처리하는 것이 특징인데, 이러한 소프트웨어의 구조는 어떻게 정의되고 동작하는지 수업 시간에 다루어진 내용 중심으로 설명해 보시오.`   
   
포인터의 반-메모리 엑세스를 통한 하드웨어 제어, 반-메모리 엑세스를 통한 osi 7계층 구현.   
메시지가 플래그/헤더/테일/데이터로 구성. 웹브라우저에서 받은 메시지는 앞뒤로 헤더와 테일이 붙는다. 계층을 지날 때마다 데이터에 헤더들이 왕창 붙는다. 올라갈때는 제거함. 메시지의 복사는 몇 번이나 이뤄질까?    
메모리에 저장된다. 메모리를 카피한다고 통신 속도가 아무리 좋아서 성능이 좋아지지 않는다. 여전히 속도가 안 올라가는 것은 램이다. 카피 많이 하면 성능 낮아짐. 레이어를 지날 때, 메모리를 copy 하지 않고 포인터를 이용해 메모리의 주소를 가르킨다. 한번 도착한 메시지는 메모리에 저장이 되므로 복사행위(복사하면 성능 느려짐) 없이 포인터로 위로 올린다.    
메모리를 제어하는 것은 통신, 하드웨어 제어, 소프트웨어 구현하는 것이다.   

## 7. 학습 내용에 대한 개인적인 총평
+ 선형대수는 강의만 수강하였다. 문제풀이는 다음주 강의까지 듣고 진행할 예정이다.
+ DLC에 대한 내용을 학습하였다.
+ 강의자료의 그림을 참고하면서 동작 방식을 이해하였다.

## 8. 다음 학습 계획
+ 선형대수 강의 수강 및 문제 풀이
+ 컴퓨터 네트워크 이론 학습