## 1. 학습 날짜
+ 2020-11-12(목)

## 2. 학습시간
+ 13:00 ~ 18:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 9시간

## 3. 학습 범위 및 주제
+ DB 물리적 설계

## 4. 동료 학습 방법

## 5. 학습 목표
+ DB 물리적 설계 강의 수강 및 실습


## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 데이터베이스 강의 수강 : 7시간    

    
#### 6.5 단일 단계 인덱스   
포인터로 데이터 화일의 레코드를 빠르게 찾을 수 있다.   
   
인덱스 : 엔트리를 관리하는 구조    
엔트리 : 탐색키 + 레코드에 대한 포인터   
엔트리는 탐색키값의 오름차순으로 정렬된다.   
   
탐색키와 레코드 포인터만 저장하기 때문이 크기가 매우 작다.   
예를 들면, 사원 릴레이션에 대해, 사원번호 인덱스와 사원이름 인덱스 2개를 정의할 수 있다.   
탐색키는 키가 아니여도 된다.   
   
- 기본 인덱스(희소인덱스)   
인덱스 중에 탐색키가 데이터 화일의 기본키인 경우.   
기본 인덱스를 사용하는 경우는 데이터 파일이 기본키에 의해 정렬되어 있는 경우가 많다   
희소 인덱스는 각 데이터 블록마다 한개의 엔트리를 갖는다.   
희소 인덱스는 각 레코드마다 한개의 엔트리를 가지는 밀집 인덱스와 대비된다.   
각 릴레이션마다 최대 1개의 기본인덱스를 가질 수 있다.   
   
희소인덱스는 엔트리의 포인터는 레코드 포인터가 아닌 블록 포인터가 된다.   
일반적으로 레코드 포인터는 블록포인터의 해당 블록 내에서의 레코드의 위치정보가 저장된다.   
따라서 레코드 포인터가 블록 포인터보다 더 많은 byte를 사용하는 것이 일반적이다.   
희소 인덱스에 나타나지 않는 키값을 갖는 레코드들도 인덱스를 통해 저장된 블록을 쉽게 찾을 수 있다.   
인덱스 엔트리들도 인덱스 블록들에 나뉘어 저장되고, 이 인덱스 블록들이 인덱스 파일을 구성한다.   
   
- 클러스터링 인덱스   
기본인덱스는 기본키에 의해 정렬된 파일에 의해 만들어지는 반면에,   
클러스터링 인덱스는 중복이 가능한 탐색키에 의해 정렬된 화일에 의해 정의된다.   
범위 질의에 유용하다.   
(그림6.18) 데이터 화일이 탐색키인 사원이름에 의해 정렬되어 있다.   
만일 조민희가 2명 있을 떄, 데이터 파일에는 조민희가 2번 나오지만, 인덱스에는 조민희가 1번만 나온다.   
인덱스 엔트리 순서와 레코드 정렬 순서가 동일하기 때문에 범위 질의를 인덱스를 통해 처리할 때 데이터 블록의 엑세스 횟수를 최소   화 할 수 있다.
   
- 기본인덱스와 클러스터링 인덱스   
기본인덱스는 기본키에 대해 만들어진 인덱스.   
기본인덱스를 만들때는 데이터 화일이 기본키에 의해 정렬되어 있는 경우가 많다.   
클러스터링(서로관련있는 것들을 묶어주는 역할) 인덱스는 기본키가 아닌 다른 탐색키에 의해 정렬되어 있고, 이에 대한 인덱스.   
기본인덱스도 기본적으로 클러스터링 인덱스이다.    
   
- 비클러스터링 인덱스   
데이터 화일이 탐색키 순서에 따라 정렬되어 있지 않기 때문에,   
범위 질의를 인덱스를 통해 처리할 때 데이터 화일에서 블록들을 랜덤하게 엑세스하게 되어 블록 엑세스 횟수가 증가한다.   
블록을 엑세스를 할 때마다 탐색시간이 요구되기 때문이다.   
   
- 보조 인덱스   
(그림 6.20)   
탐색키에 따라 정렬되지 않는 데이터 화일에 대해 정의된다.   
이 경우 각 레코드마다 대응되는 하나의 인덱스 엔트리를 가져야 한다.   
따라서 이러한 인덱스는 밀집 인덱스가 된다.    
(그림 6.21) 데이터 화일이 기본키인 탐색키에 의해 정렬되어 있을 때의 밀집인덱스 예   
이것은 기본인덱스를 밀집인덱스로 표현한 것으로 보면 된다. 일반적으로 기본인덱스는 희소인덱스로 표현되지만 말이다.   
   
탐색이 자주 일어나는 애트리뷰트에 대해서 탐색키를 가지고 보조인덱스를 만들 수 있다.   
   
- 보조 인덱스 vs 기본 인덱스   
기본 인덱스는 데이터화일이 정렬되어 있어야 하기 때문에, 데이터 화일을 다른 순서대로 정렬이 불가능하다.   
즉, 한가지 정렬 순서에 의해서만 데이터 화일이 구성될 수 있다.   
따라서 기본인덱스는 하나만 존재할 수 있는 반면에   
보조인덱스는 데이터의 정렬여부와 독립적이기 때문에 여러 개의 보조인덱스를 가질 수 있다.   
   
   
- 희소 인덱스 vs 밀집 인덱스   
희소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적이다   
데이터 레코드를 삽입, 삭제할때마다 인덱스가 갱신되어야 하는 밀집 인덱스와 달리, 인덱스가 변경되지 않는 경우가 많기 때문이다.   
한 화일은 한 개의 희소 인덱스와 다수의 밀집 인덱스를 가질 수 있음   
   
희소 인덱스의 엔트리 수가 훨씬 더 작다.   
만약 포인터가 물리적인 포인터라면, 블록포인터에다가 레코드의 위치를 붙인것이 레코드 포인터가 된다. 그래서 레코드 포인더의 길   이가 더 길다.
경우에 따라서는 물리적 포인터가 아닌 논리적 포인터를 사용할 수 있다.   
논리적 포인터란, 특별하게 일종의 식별자를 포인터마다 하나 부여하고, 그 식별자에 대응되는 물리적 포인터를 관리하는 mapping ta   ble을 따로 관리하는 것이다.
이런 경우 블록포인터와 레코드 포인터의 길이가 같게 될 수도 있다.   
   
- 클러스터링 인덱스 vs 보조 인덱스   
   
----------------------------------------------------------
#### 6.6 다단계 인덱스
단일 단계 인덱스의 엔트리 수가 많아지고, 인덱스 블록 수가 많아지면, 인덱스 블록에 대한 이진탐색도 오래걸려서   
이것을 빨리 찾기 위해 단일단계 인덱스위에 또 하나의 인덱스를 만들게 된 것이 다단계 인덱스다.    
최종적으로 만들어진 인덱스 블록이 1개가 될때까지 인덱스를 생성한다.   
b+트리는 b트리의 변형   
   
1단계 인덱스는 단일단계에서 사용된 인덱스이다   
1단게 인덱스에 대해 희소 인덱스를 생성하면 2단계 인덱스가 된다.   
2단게 인덱스에 대해 희소 인덱스를 생성하면 3단계 인덱스가 된다.   
3단계 인덱스는 하나의 블록에 들어가므로 더이상 상위 인덱스가 없다.   
최상의 인덱스를 마스터 인덱스라고 한다.   
다단계 인덱스에서의 삽입,삭제,탐색은 항상 마스터 인덱스에서 시작된다.   
   
3단계 인덱스는 주기억장치의 버퍼 풀에 상주한다고 가정한다.   
   
- SQL의 인덱스 정의문   
   
- 다수의 애트리뷰트를 사용한 인덱스 정의   
DNO는 단독으로 인덱스로 활용될 수 있고, SALARY는 단독으로 인덱스로 활용될 수 없다.   
그 이유는 인덱스 정의할 때 사용된 애트리뷰트 순서 때문이다.   
주어진 애트리뷰트 순서에 따라 첫번째 애트리뷰트에 의해 정렬되고, 첫번째 애트리뷰트 값이 같은 경우 두번째 애트리뷰트에 의해    정렬된다.
따라서, 인덱스 정의에 사용된 애트리뷰트 중 첫번재 애트리뷰트에 대한 조건이 없이 두번째 애트리뷰트에 대해서만 조건이 주어지면    인덱스를 활용할 수 없다.
   
- 인덱스 사용의 장단점   
   
---------------------------------------------------------------
#### 6.7 인덱스 선정 지침과 DB 튜닝
선별력(Selectivity) : 전체 투플 개수중에 조건에 의해 선택되는 투플의 비율   
물리적 데이터베이스 설계는 DB를 사용하는 라이프사이클 동안 반복적으로 수행되어야 하는 작업이다.   
   
- 인덱스 선정하는데 도움이 되는 지침    
1 :   
2 : 외래키가 조인에  자주 사용된다는 것을 고려해보면, 인덱스의 중요한 후보가 된다.   
3 :   
4 :   
5 : 인덱스 갱신의 오버헤드가 커지기 때문   
6 : 인덱스 갱신의 오버헤드가 커지기 때문   
7 : 그렇지만, 기본키로 선정되지 않았기에 후보키가 DB운영에 중요한지 숙고해야 한다.    
8 : 인덱스 애트리뷰트의 각 값마다 적은 수의 레코드들만 존재하면, 인덱스는 파일의 레코드들을 충분히 분할한 것이다.   
9 : 가능하면 정수형 애트리뷰트에 인덱스를 생성하는 것이 좋고, 그 다음에 고정길이 애트리뷰트에 인덱스를 생성하는 것이 좋다.   
10 :   
11 : 데이터 화일의 순차적 스캔보다 성능이 개선될 떄 인덱스를 만들어야 한다.   
12 :   
   
   
- 인덱스가 정의되어 있음에도 사용되지 못하는 경우가 있다.   
1. 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타냄 -> 8장에서 설명함   
2. DBMS의 질의 최적화 모듈이 릴레이션의 크기가 작아서 인덱스가 도움이되지 않는다고 판단함   
예를 들면, 릴레이션의 투플이 50개 정도만 있어서, 순차적 데이터 화일 스캔이 인덱스를 이용한 엑세스보다 빠르다고 판단되면 인덱   스를 사용하지 않는다.
3. 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용됨   
인덱스에는 산술 연산자가 적용되지 않은 애트리뷰트값이 사용되기 때문이다.   
4. DBMS가 제공하는 내장 함수가 사용됨.   
내장함수가 사용되면 인덱스가 사용되기 어렵다   
5. 널값에 대해서는 일반적으로 인덱스가 사용되지 않음   
DBMS에 따라 인덱스에는 널값을 관리하지 않기 때문이다.   
   
- 질의 튜닝을 위한 추가 지침   
1. DISTINCT절의 사용을 최소화하라   
중복값을 제거하기 위해 정렬, 해싱 등의 추가적인 작업이 필요하기 때문이다.   
2. GROUP BY절과 HAVING절의 사용을 최소화하라   
GROUPING 처리도 시간이 오래걸리는 작업이기 때문이다.   
3. 임시 릴레이션의 사용을 피하라   
하나의 큰 질의를 임시 릴레이션을 사용하여 2개 이상의 질의로 나누게 되면, 각 질의에 대해 질의최적화가 이루어져서, 전체 질의에    대해 최적화한 것에 비교하여 성능이 나쁘게 될 수 있다.
또한, 임시 릴레이션을 저장하고 읽는데 추가적인 시간이 요구되기도 한다.   
4. SELECT * 대신에 SELECT절에 애트리뷰트 이름들을 구체적으로 명시하라   
SELECT *를 사용하게 되면 모든 애트리뷰트가 포함되기 때문에 불필요한 네트워크 트래픽이 증가하고, 질의에서 무슨 애트리뷰틀 원   하는지 명확하지 않으므로, 애트리뷰트 이름들을 구체적으로 나열하는 것이 좋다.
   
워크로드(workload) : DBMS를 사용하는 트랙잭션들의 집합. 어떠한 연산들이 사용되는지 빈도정보와 함께 가지고 있는 것   
   
   
- 연습문제 - 물리적데이터베이스 설계   
   
1번 문제   
(1) 기본인덱스의 포인터는 블록을 가르킨다.   
(2) 밀집인덱스의 포인터는 레코드를 가르킨다.   
인덱스 블록킹 인수는 데이터 화일의 블로킹 인수와 다르다.   
보통 데이터 화일의 레코드 수보다 엔트리 개수가 적기 때문에 인덱스의 블록킹 인수가 더 크다.   
(이 문제에서 index blocking 인수가 5개라고 가정)   
(3) 인덱스는 순서대로 정렬되어야 한다. 알파벳순서. 총 엔트리 개수는 10개. 포인터는 애트리뷰트를 가리키는 것이 아니고 해당 레   코드 전체를 가르킨다.
희소인덱스는 정렬된 데이터 화일에 사용된 키값 순서와 일치하는 것에 대해서만 희소인덱스를 사용할 수 있다.   
일반적으로 보조인덱스는 정렬되는 키값과는 다르기 때문에 밀집인덱스를 사용한다.   
   
Q. index blocking 인수가 5개라고 하셨는데 보조 인덱스에서는 적용을 안하는 건가요?   
A. 보조인덱스도 당연히 적용을 한다.   
   
Q. 교수님 아까 수업에서 인덱스에 VARCHAR 애트리뷰트를 쓰지 않는다는 이유가 궁금합니다    
A. 인덱스를 만들 때는 정수형, 문자열인 경우에는 고정길이문자열이 좋다. 왜냐면, 가변 길이 문자열에 대해서는 인덱스를 관리하고    탐색할 때 시간이 오래 걸리기 때문이다.
   
Q. 같은 레코드를 가르키는 블록 포인터와 릴레이션 포인터가 같은건가?   
A. 블록 포인터가 b0라면, 해당 블록의 첫번째 레코드 R0는 (b0, 0)라고 표시할 수 있다. R1은 (b0, 1).   
   
   
2번 문제   
(1) 레코드 길이 : 15+13+8+37+11+1+10+4 = 99 byte   
(2) 1024/99 =10.3434 --> 블로킹 인수는 10   
(3) 30000 / 10 = 3000 개의 블록이 필요하다.   
(4)   
A. 1024 / (13+ 4)((주민등록번호 크기) +(블록포인터 크기)) = 60.23529.. --> 인덱스의 블로킹 인수는 60   
B. 1단계 인덱스 엔트리 수 : 3000개(희소 기본인덱스이므로 블록포인터를 갖는다. 즉, 데이터 화일의 블록개수만큼 엔트리를 갖는다   ),
1단계 인덱스 블록 수 : 3000/60 = 50개   
C. 1단계 인덱스 블록 수 : 50개   
2단계 인덱스 블록 수 : 50 / 60 &lt; 1. 1보다 작기 때문에 1개의 블록을 가진다. 즉, 2단계 인덱스가 마스터 인덱스이다.   
D. 단일단계 인덱스 사용시 : 2번(1단계 1번 + 데이터 화일 1번)   
다단계 인덱스 사용시 : 2번(1단계 1번 + 데이터 화일 1번), 마스터 인덱스는 주기억장치 상에 존재하므로 디스크 접근이 필요 없다.   



## 7. 학습 내용에 대한 개인적인 총평
+ 마크다운에서 부등호 &lt;는 ```&lt;```로, &gt;는 ```&gt;``` 로 표시한다.
+ 물리적 설계에 대한 내용을 철저하게 복습하고 실습까지 하였다.
+ 물리적 설계는 용어들이 너무 생소하고, 헷갈려서 강의를 두번 반복하여 모두 받아적으며 복습하였다.
+ 시간도 오래걸리고 힘들었지만, 그래도 이렇게 하여 물리적 설계에 대한 내용을 이해할 수 있었다. 처음 강의 듣고 나서는 정말 무슨 소린지 모르겠을 정도로 내용이 어려웠다.
+ 레코드 길이, 엔트리 개수, 블록킹 인수, 인덱스의 블록킹 인수 등을 계산하는 문제를 풀어보면서, 개념을 완전히 이해할 수 있었다.
+ 과제를 혼자 힘으로 풀었는데, 한번에 다 맞아서 기분이 좋다.
+ 벌써 12시가 넘었다. 결국 하루종일 물리적 설계만 공부하였다..

## 8. 다음 학습 계획
+ Backtracking, BB 알고리즘 강의 수강 및 학습