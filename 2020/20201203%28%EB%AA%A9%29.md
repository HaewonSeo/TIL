## 1. 학습 날짜
+ 2020-12-03(목)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 8 시간

## 3. 학습 범위 및 주제
+ DB 동시성 제어 및 회복

## 4. 동료 학습 방법

## 5. 학습 목표
+ 동시성 제어 및 회복 학습


## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ DB 강의 수강 : 3시간    

### 9.3 회복   
   
- 회복의 필요성   
- 회복의 개요   
   
   
- 저장 장치의 유형   
안전저장장치 : 모든 유형의 고장을 견딜 수 있는 저장 장치,   
안전저장자치는 물리적인 저장공간 아니다. 여러개의 사본을 가진다는 것   
   
- 재해적 고장과 비재해적 고장   
재해적 고장   
비재해적 고장 : 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용   
   
- 로그를 사용한 즉시 갱신   
   

- 로크 레코드의 유형   
   
- 로그 먼저 쓰기(WAL: Write-Ahead Logging)   
회복기법에서 중요한 로그 먼저쓰기   
아주 중요.   
데이터베이스 버퍼의 내용을 디스크에 기록하기 전에 로그 버퍼의 내용을 기록해야 한다.   
   
로그는 순차파일이다   
새로운 로그 레코드들이 계속해서 append되는 것임. 항상 뒤쪽에 써진다.   
로그 버퍼를 디스크에 기록해야 한다면, 앞의 정보들이 write된다.앞의 정보륻 버퍼에서 지울 수 있다. 로그버퍼는 링(ring)형태로 유지한다. 제한된 로그 버퍼 메모리를 효율적으로 사용할 수 있다.   
 
~처리시간이 오래 걸릴 수 있다.    
- 체크포인트(checkpoint) 필요성   
   
- 체크포인트를 할 때 수행되는 작업   
   
- 데이터베이스 백업과 재해적 고장으로부터의 회복   
   
--------------------------------------------------------------------   
   
로그를 기반으로 한 즉시 갱신 : 데이터베이스에 바로 기록   
로그를 기반으로 한 지연 갱신 : 로그에 write를 해놓았다가 나중에 해당되는 연산이 포함되는 트랜잭션이 커밋되었을 때 로그를 기반으로 데이터베이스에 갱신하는 것   
   
- 그림자 페이징(shadow paging)   
FAT(file allocation table) : 파일을 구성하는 페이지(데이터블록의 다른이름)을 가지고 있는 것   
 
   
- 로그   
로그파일 : append only, 계속적으로 증가하는 파일. 파일의 크기가 커질 수 있다. 오래된 내용은 불필요하거나 즉시 필요하지 않을 수 있다. 이럴 경우 로그파일의 앞부분은 백업하여 관리하게 된다.   
LSM : log Sequence Number 가 부여된다.   
[Trans-ID, X, old_value, new_value]   
   
X: 일반적으로 레코드 단위로 로그를 수행한다고 하면,  X는 레코드 식별자. 또는 페이지 단위로 한다면, X는 페이지 식별자가 된다.   
old value는 나중에 UNDO 연산 시 필요하다   
new value : READ를 위해 필요하다. Commit 한 경우 재수행을 위해 필요하다.   
   
로그레코드는 DBMS마다 차이가 많이 난다.   
OLD/NEW VALUE를 모두 기록해야 하는 경우 로그의 양이 커질 수 있다. 이런 것을 PHYSICAL LOG RECORD라고 하는데(OLD/NEW VALUE의 BYTE 값을 기록하는 것)   
Physical log record의 반대는 LOGICAL Log Recod.    
[Trans-ID, TYPE_INCREMENT, X , 3] : X를 3증가하였다는 의미.  나중에 REDO하면 똑같이 +3해주면 되고, UNDO하게 되면 -3해주면 된다.   
어떤 경우에는 Physical, logical 모두 사용하는 hybrid를 사용하기도 한다.   
   
- WAL(Write-Ahead Logging, 로그 먼저 쓰기)   
메모리 상의 로그버퍼/DB버퍼   
디스크 상의 로그파일/DB파일   
DB버퍼에 77page를 DB파일에 write   
77페이지의 A->B write   
시스템을 커밋하지 않고, 시스템이 다운되었다.   
DB파일의 B를 철회해야 하는데, 이에 대한 로그레코드가 없기 때문에 철회가 불가능하다.   
   
따라서, 페이지의 갱신연산을 먼저 로그에 기록해야 한다.   
그러면, 항상 데이터베이스에 반영된 로그레코드는 디스크의 로그파일에 기록되어 있다.   
   
Q. 그러면, 77페이지에 write하려고 할 떄 로그버퍼에는 로그블락들이 많이 있는데, 어떤 로그블락 하나가 A->B의 기록을 가지고 있다. 이 LSN을 어떻게 알 수가 있을까?   
효율적인 방법은?   
   
A.    
방법1 : DB 버퍼 페이지마다 로그 레코드 리스트를 관리   
로그버퍼는 링버퍼로 관리한다. 제한된 메모리를 무한대처럼 사용하기 위해 사용한다.   
한 블록을 포함하는 곳까지 flush하게 된다.   
로글 다 가지고 있으면, 하나의 DB페이지에 대해서 연산횟수가 많을 수 있어 메모리공간에 대한 오버헤드가 있고, DB페이지마다 연산 횟수가 다르기 때문에 메모리 관리가 어렵다   
   
방법2 : pageLSN   
따라서, 마지막 LSN만을 가지고 있는다.(Page LSN) 각각의 DB페이지마다 블록헤더 중에 pageLSN을 기록하는 필드가 있다. 업데이트가 발생하면, 업데이트에 대한 로그레코드를 기록.    
이것이 가장 많이 구현하는 방법   
그런데 pageLSN이 이러한 용도 말고도 다른 용도로 사용가능하다.   
커밋한 트랜잭션이 디스크에 =저장되지 않으면 재수행한다.   
어떤 페이지에는 반영되고, 어떤 페이지에는 반영되지 이ㅏㄶ았을 수 있다.   
pageLSN을 로그레코드의 LSN과 비교한다.   
pageLSN이 17라면, 17번까지는 redo할 필요가 없다. 20번은 UNDO할 필요가 없다.   
   
- check point   
은행과 같은 경우에는 트랜잭션을 중단할 수 없다.   
모든 트랜잭션을 중지하지 않고 하는 check point기법 : fuzzy checkpoint.    
fuzzy(애매하다는 뜻, 0~1사이의 값을 가질 수 있다.)  binary logic(0 vs 1)   
   
체크포인트를 할 때, 체크포인트 시작 로그 레코드를 기록. DB를 정상동작하듯이 로그레코드를 기록한다. 그 다음에 end 체크포인트를 기록한다.   
체크포인트 중간에 수행된 레코드를 반영해 ~   
   
### 9.4 PL/SQL의 트랜잭션 - 오라클의 예   
PL/SQL :오라클에서 프로그래밍언어와 함께 SQL을 사용하는 언어   
savepoint   
   
- 동시성 제어의 고립 수준   
- READ UNCOMMITTED   
- READ COMMITTED   
- REPEATABLE READ   
- SERIALIZABLE : 추가적으로 엔덱스에 대한 공유 로킹.   
   
갱신 손실은 어떤 고립수준에서도 나타날 수 없다.   
고립수준이 높은 만큼 동시성 제어가 낮아져 성능이 낮아진다.   
응용에 맞는 적합한 고립수준을 선택하여야 한다.   
   
   
팬텀은 범위질의가 있을때 발생할 수 있다.   
범위질의에 속하지 않는 투플이 나타날 수 있다.   
   
팬텀을 해결하기 위해서는 데이터베이스 항목이 아닌 범위에 로크를 하면 된다.   
범위에 대해 로크를 거는 것은 비용이 많이 든다.   
그것을 간단하게 하는 것이 인덱스를 활용한 로크   
   
next key value locking    
6을 삽입하면, 7에 대한 로킹을 요청   
이 방법으로 팬텀 문제를 해결할 수 있다.   
    

## 7. 학습 내용에 대한 개인적인 총평
+ 로그에 대해서 자세히 학습하였는데, 아직 이해하지 못한 부분이 있어 복습이 필요하다.
+ 데이터베이스에 설계 시 고려해주어야 할 부분이 많은 것 같다.
+ SQL문은 기본이고 동시성 제어와 회복과 같은 필수적인 기능들에 대한 이해가 필요하다.
+ 동시성 제어의 고립 수준을 설정함으로써 DBMS의 성능을 결정할 수 있다.
+ pageLSN에 대한 내용도 복습이 필요하다.


## 8. 다음 학습 계획
+ 소프트웨어공학 범위,일정,비용 관리 학습
+ 컴퓨터구조 학습