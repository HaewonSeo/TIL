## 1. 학습 날짜
+ 2020-12-15(화)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)    
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ 데이터베이스

## 4. 동료 학습 방법


## 5. 학습 목표
+ 데이터베이스 회복 학습
+ 권한 관리 학습


## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 데이터베이스 강의 수강 : 3시간    

    
<9.3 회복>   
   
- 저장 장치의 유형   
안전저장장치 : 모든 유형의 고장을 견딜 수 있는 저장 장치,   
안전저장장치는 고장이 나지 않는 장치. 물리적인 저장공간 아니다.   
안전저장장치를 근사하게 구현하는 방법은 여러개의 사본을 가지는 것. 두 개 모두 고장날 확률은 굉장히 낮다.   
   
- 재해적 고장과 비재해적 고장   
재해적 고장 : 디스크 손상->백업을 사용해야 함.   
비재해적 고장 : 재해적 고장 이외의 고장   
대부분의 회복 알고리즘들은 비재해적 고장에 적용된다 -> 디스크가 손상되지 않는 경우.   
대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용하고 있다.   
   
- 로그를 사용한 즉시 갱신   
갱신에 대한 내용을 로그로 기록한다.   
로그에 대해서도 디스크 입출력 성능 향상을 위해 로그 버퍼를 유지한다.   
   
동일한 트랜잭션에 속하는 로그레코드들은 연결 리스트로 유지된다.   
-> 즉, 로그 레코드는 동일 트랜잭션에 속한 이전 로그레코드의 LSN을 포함한다.   
   
로그는 순차파일이다.    
새로운 로그 레코드들이 계속해서 append되는 것임. 항상 뒤쪽에 써진다.   
로그 파일은 디스크 블록으로 구성. 디스크 블록들이 로그 버퍼에 올라가 있다.    
로그 버퍼를 디스크에 기록해야 한다면, 앞의 정보들이 write된다.앞의 정보륻 버퍼에서 지울 수 있다.   
로그버퍼는 링(ring)형태로 유지한다. 제한된 로그 버퍼 메모리를 효율적으로 사용할 수 있다.   
   
   
- 로크 레코드의 유형   
   
- 로그 먼저 쓰기(WAL: Write-Ahead Logging)   
회복기법에서 중요한 로그 먼저쓰기(아주 중요)   
데이터베이스 버퍼의 내용을 디스크에 기록하기 전에, 로그 버퍼의 내용을 디스크에 기록해야 한다.   
   
Q. 그렇다면, 기록될 데이터베이스 버퍼 페이지가 주어졌을 때, 로그 버퍼는 얼마나 디스크에 기록되어야 할까?   
   
   
- 체크포인트(checkpoint) 필요성   
시스템이 다운된 후 회복할 때 로그의 처음부터 수행하면, 처리시간과 비용이 클 수 있다.    
   
- 체크포인트를 할 때 수행되는 작업   
수행 중인 트랜잭션들을 일시적으로 중지시킴   
그런데, 이 방법은 성능상 문제가 있을 수 있다.   
회복 알고리즘에 따라서, 예를 들면 fuzzy check point는 이 작업이 필요없다.   
   
--------------------------------------------------------------------   
<12/3>   
   
- 로그를 기반으로 한 즉시 갱신 : DB에 write연산 시 데이터베이스에 바로 기록하고, 그 다음에 로그에 기록. DB에 바로 기록하는 것.   
- 로그를 기반으로 한 지연 갱신 : 데이터베이스에 바로 기록하는 것이 아니라, 로그에 write를 해놓았다가 나중에 해당되는 연산이 포함되는 트랜잭션이 커밋 한다고 했을 때 로그를 기반으로 데이터베이스에 갱신하는 것   
   
- 그림자 페이징(shadow paging)   
FAT(file allocation table) : 파일을 구성하는 페이지(=데이터블록)을 가지고 있는 것   
특정 페이지를 업데이트 했을 때 바로 반영하는 것이 아니고, 페이지의 복사본을 만들고 업데이트를 복사본에 반영한다.   
FAT를 복사한 FAT'는 복사된 페이지를 가르킨다.   
트랜잭션이 커밋되면, FAT'로 replace한다.   
만약 트랜잭션이 철회되면, FAT'를 그냥 날려버리면, 원래 페이지는 변경 사항이 없기 때문에 철회가 이루어진다.   
   
- 로그   
로그파일 : append only, 계속적으로 증가하는 파일. 파일의 크기가 커질 수 있다.   
오래된 로그 파일의 내용은 불필요하거나 즉시 필요하지 않을 수 있다. 이럴 경우 로그파일의 앞부분은 백업하여 관리하게 된다.   
각각의 로그레코드에는 순차적으로 번호를 부여한다. LSN   
LSN : log Sequence Number 가 부여된다.   
   
[Trans-ID, X, old_value, new_value]   
X: 일반적으로 레코드 단위로 로그를 수행한다고 하면,  X는 레코드 식별자. 또는 페이지 단위로 한다면, X는 페이지 식별자가 된다.   
old value는 나중에 UNDO 연산 시 필요하다   
new value : REDO를 위해 필요하다. DB에는 반영되어 있지 않지만, Commit 한 경우 재수행을 위해 필요하다.   
   
로그레코드는 DBMS마다 차이가 많이 난다.   
OLD/NEW VALUE를 모두 기록해야 하는 경우 기록해야 할 로그의 양이 커질 수 있다.   
이런 것을 PHYSICAL LOG RECORD라고 하는데(OLD/NEW VALUE의 BYTE의 값을 기록하는 것)   
Physical log record의 반대는 Logical Log Recod.    
[Trans-ID, TYPE_INCREMENT, X , 3] : X를 3증가하였다는 의미.  나중에 REDO하면 똑같이 +3해주면 되고, UNDO하게 되면 -3해주면 된다.   
어떤 경우에는 Physical, logical 모두 사용하는 hybrid를 사용하기도 한다.   
   
- WAL(Write-Ahead Logging, 로그 먼저 쓰기)   
메모리 상의 로그버퍼/DB버퍼   
디스크 상의 로그파일/DB파일   
DB버퍼에 77page를 DB파일에 write   
77페이지의 A->B write   
(가정1)시스템을 커밋하지 않은 상태에서 시스템이 다운되었다.   
(가정2) A->B된 로그 버퍼는 아직 로그파일에는 write되지 않았다.   
DB파일에 write된 B를 철회해야 하는데, 이에 대한 로그레코드가 없기 때문에 철회가 불가능하다.   
   
따라서, DB파일에 wirte되는 페이지의 갱신연산에 대한 로그레코드들을 먼저 로그파일에 기록해야 한다.   
그러면, 항상 데이터베이스에 반영된 로그레코드는 디스크의 로그파일에 기록되어 있다.   
   
Q. 그러면, DB버퍼의 77페이지를 DB 파일에 write하려고 할 떄,   
로그버퍼에는 로그블락들이 많이 있는데, 이 중 어떤 로그블락이 A->B의 기록을 가지고 있는지 알 수 있을까?   
이것의 LSN을 어떻게 알 수가 있을까? 효율적인 방법은?   
   
A.    
방법1 : DB 버퍼 페이지마다 로그 레코드 리스트를 관리   
방법 1의 문제?   
->    
사실 로그버퍼는 링버퍼 형태로 관리한다. 링 형태는 제한된 메모리를 무한대처럼 사용하기 위해 사용한다.   
더 이상 링버퍼에 공간이 없으면 링버퍼의 차지하고 있는 공간을 flush하게 된다.   
갱신되는 DB 페이지마다 로그를 다 가지고 있으면, 하나의 DB페이지에 대해서 갱신 연산횟수가 많을 수 있기 때문에   
메모리공간에 대한 오버헤드가 있고, DB페이지마다 연산 횟수가 다르기 때문에 메모리 관리가 어렵다   
   
그래서 모든 갱신연산에 대한 LSN을 가지고 있는 것이 아니라, 마지막 갱신 연산에 대한 LSN만 가진다.   
->pageLSN   
방법2 : pageLSN   
따라서, 마지막 LSN만을 가지고 있는다.(Page LSN)   
각각의 DB페이지마다 블록헤더 중에 pageLSN을 기록하는 필드가 있다. 업데이트가 발생하면, 업데이트에 대한 로그레코드를 pageLSN에 기록.    
이것이 가장 많이 구현하는 방법.   
   
그런데 pageLSN이 이러한 용도 말고도 다른 용도로 사용가능하다.   
커밋한 트랜잭션이 디스크에 반영되지 않으면 재수행한다.   
트랜잭션의 연산 중 어떤 연산은 반영되고, 어떤 연산이 반영되지 않았을 수 있다.   
pageLSN을 로그레코드의 LSN과 비교한다.   
만약, 10번 레코드를 재수행해야 하는데,   
pageLSN이 17라면, 10번 ~17번까지는 redo할 필요가 없다.   
마찬가지로 UNDO해야 할 레코드가 20번이라면,   
17번까지 DB파일에 기록되어 있으므로 20번을 UNDO할 필요가 없다.   
만약 10번을 UNDO해야 하면, 10~17번이 UNDO되어야 한다.   
   
회복하는데 걸리는 시간을 줄이기 위해 check point를 사용한다.   
- check point   
현재 실행중인 트랜잭션을 중지하고, 로그와 DB를 디스크에 저장한다.   
그런데 은행과 같은 경우에는 트랜잭션을 중단할 수 없다.   
모든 트랜잭션을 중지하지 않고 하는 check point기법 : fuzzy checkpoint.    
fuzzy(애매하다는 뜻, 0~1사이의 값을 가질 수 있다.)  <-> binary logic(0 vs 1)   
fuzzy checkpoint : 체크포인트 시점이 애매하다는 뜻. 왜냐면 트랜잭션을 중단시키지 않았기 때문   
체크포인트를 할 때, 체크포인트 시작 시점을 로그 레코드에 기록. 그 다음 DB를 정상동작하듯이 로그레코드를 기록한다. 그 다음에 end 체크포인트를 기록한다.   
나중에 체크포인트를 분석 할 때, 체크포인트 중간에 수행된 연산을 반영해서 회복을 하게 된다.   
   
   
   
<9.4 PL/SQL의 트랜잭션> - 오라클의 예   
PL/SQL :오라클에서 프로그래밍언어와 함께 SQL을 사용하는 언어   
   
savepoint   
   
- 동시성 제어의 고립 수준   
응용이 요구하는 데이터베이스의 정확성에 따라 고립수준을 선택하면 된다.   
- READ UNCOMMITTED   
- READ COMMITTED   
- REPEATABLE READ   
- SERIALIZABLE : 추가적으로 엔덱스에 대한 공유 로킹.   
   
갱신 손실은 어떤 고립수준에서도 나타날 수 없다. -> 이것은 DB의 일관성을 파괴하기 때문.   
고립수준이 높은 만큼 동시성 제어가 낮아져 성능이 낮아진다.   
따라서, 응용에 맞는 적합한 고립수준을 선택하여야 한다.   
   
   
팬텀 문제는 범위질의가 있을때 발생할 수 있다.   
범위질의에 속하지 않는 투플이 나타날 수 있다.   
   
팬텀을 해결하기 위해서는 데이터베이스 항목이 아닌 범위에 로크를 하면 된다.   
그런데 범위에 대해 로크를 거는 것은 비용이 많이 들고 어렵다.   
그것을 간단하게 하는 것이 인덱스를 활용한 로크   
   
next key value locking    
6을 삽입할 때, 6을 삽입하는 것이 아니라, 6 다음인 7에 대한 로크을 요청   
1부터 10까지 읽는다면, 7에 로크가 있어 6을 따로 삽입하지 못한다.   
이 방법으로 팬텀 문제를 해결할 수 있다.   
   
   
---------------------------------------------------------------------------------------   
<12/08>   
   
<10 데이터베이스 보안과 권한 관리>   
최근 보안은 중요한 이슈   
   
<10.1 데이터베이스 보안>   
   
무결성은 권한이 있는 사용자로부터 데이터를 보호하는 것이고,   
보안은 권한이 없는 사용자로부터 데이터베이스를 보호하는 것이다.   
   
- 임의 보안 기법   
grant/revoke   
   
- 강제 보안 기법   
데이터와 사용자들을 다양한 보안 등급으로 분류   
   
<10.2 권한 관리>   
   
- 권한 허가   
GRANT절에 SELETE/UPDATE가 오면 애트리뷰트 리스트가 뒤에 온다.   
애트리뷰트 리스트가 생략되면, 모든 애트리뷰트에 대한 권한이 얻는다.   
권한을 받는 대상은 사용자/역할/Public(모든사용자)가 있다.   
WITH GRANT OPTION : 권한을 허가받은 사용자가 또다른 사용자에게 권한을 허가할 수 있다.   
   
- 권한 취소   
REVOKE   
권한이 취소되면, 연쇄적 취소된다.   
   
- 역할   
CREATE ROLE   
역할 없이 권한을 허가하면, 권한들의 모음을 동일하게 각 사용자에게 허가해야 하며, 필요한 권한이 바뀌는 경우 개별사용자에게 다시 적용해야 하므로 관리하기 어렵다.   
역할을 사용하여 권한을 허가하면, 권한들의 모음으로 역할을 만들고 이 역할을 사용자에게 허가하므로, 필요한 권한이 바뀔때 역할에 부여한 권한만을 바꿈으로써 유연하게 대응할 수 있다.   
   
   
<10.3 오라클의 보안 및 권한 관리>   
   
권한 종류에 따라서 데이터 사전의 종류도 달라진다.   
   
- 시스템 권한의 허가   
ANY 는 사용자가 임의의 스키마에서 수행할 수 있는 권한을 가졌음을 의미한다.   
CREATE TABLE 권한을 받은 사용자는 그 테이블을 삭제하는 권한도 있다.   
WITH ADMIN OPTION;   
시스템 권한을 취소할 때는 연쇄적인 취소가 일어나지 않음!   
   
- 객체 권한   
뷰에서는 REFERENCES 권한을 허용할 수 없다.   
   
- 미리 정의된 역할   
CONNECT 역할만 있으면, 테이블과 인덱스를 생성할 수는 없다.   
DBA   
   
- 데이터베이스 관리자 역할   
SYSDBA : 데이터베이스와 데이터베이스 내의 모든 객체에 대해 임의의 연산을 수행할 수 있다.   
   
   
- 모든 권한 취소   
REVOKE ALL : 특정 테이블에 대한 권한 모두 취소   
REVOKE ALL PRIVILEGES : 사용자의 전체 권한 취소   
   
- 일부 권한 취소   
   
- 사용자 LEE로 로그인해서 EMPLOYEE 테이블 대한 질의들을 수행   
사용자 X가 만든 객체의 소유자는 X이고, 이 객체들을 X스키마라고 한다.   
오라클 시스템 정보를 담고 있는 데이터 딕셔너리의 소유자는 SYS이다. 따라서, 데이터 딕셔너리는 SYS스키마이다.   
   
- 사용자 LEE에 대해서 EMPLOYEE 테이블에서 SALARY 애트리뷰트를 제외한 애트리뷰트들만 SELECT할 수 있도록 하려면   
뷰를 생성하여 애트리뷰트 단위로 SELECT 권한을 허가할 수 있다.   
INSERT, UPDATE,M REFERENCES 권한은 애트리뷰트 단위로 허가할 수 있다.    
   
시스템의 소유자는 SYS이다.   
데이터 딕셔너리는 SYS SCHEMA라고 할 수 있다.   
   
- 동의어(synonym) 정의   
HR.EMPLOYEE 여기서 HR은 데이터베이스 스키마(LIVESQL)   
KIM.EMPLOYEE을 사용할 때의 KIM은 사용자 스키마 이름을 지칭하는 것임.(사용자가 아님)   
사용자가 생성한 데이터베이스 객체는 사용자 이름과 동일한 이름의 스키마에 속하게 된다.   
사용자 스키마는 사용자가 생성한 데이터베이스 객체를 모두 포함한다.  

## 7. 학습 내용에 대한 개인적인 총평
+ 데이터베이스의 회복에 대한 내용을 학습하였다.
+ 데이터베이스 권한 관리에 대한 내용을 학습하였다.
+ 프로젝트 배포 과정에서 권한 관리에 대한 지식이 부족하여 관련 내용을 검색하였었는데, 이에 대한 내용을 구체적으로 학습하였다.
+ 데이터베이스는 몸은 힘들었으나 남는 것이 많은 수업이었다.
+ 데이터베이스 수강은 훌륭한 선택이었다.


## 8. 다음 학습 계획
+ 알고리즘분석 기말고사 대비