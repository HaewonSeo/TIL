## 1. 학습 날짜
+ 2020-10-16(금)

## 2. 학습시간
+ 13:00 ~ 15:00 (자가)   
+ 19:00 ~ 24:00 (자가)
+ 총 학습시간 : 7시간

## 3. 학습 범위 및 주제
+ 소프트웨어공학 

## 4. 동료 학습 방법

## 5. 학습 목표
+ 소프트웨어 개발에 대한 오해와 실체 학습
+ 소프트웨어 개발방법론 학습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 소프트웨어공학 강의 수강 : 2시간    


**2. 소프트웨어 개발에 대한 오해와 실체**    
- 소프트웨어 공학 정의    
소프트웨어공학은 실제 효과적으로 작동할 수 있는 우수한 소프트웨어를 최저그이 비용으로 얻기 위하여 사용하는 견고한 엔지니어링 원칙    
허용하는 예산과 시간 내에서 효과적으로 소프트웨어제품을 개발하고, 유지 보수하는 활동과 관련된 기술적, 관리적 원리   
주요 목표는 품질을 향상시키고 생산성, 사용자 만족도를 증진하는데 있다.   
소프트웨어 시스템의 개발,운용,관리에 적용되는 체계적인 접근방법    
    
**2.1 소프트웨어와 관련된 질문들**    
- 프로그래밍 개발비용 : 소프트웨어 개발의 경우 프로그래밍에 전체 개발의 약 20%가 소요된다.    
프로그래밍은 기계적인 일    
요구사항분석,설계가 중요한 이유가 이 과정이 체계적으로 이루어지지 않으면, 좋은 품질을 기대하기 어렵다    
건축/하드웨어는 제조되는 반면, 소프트웨어는 엔지니어링 되는 것.    
요구사항분석,설계(40%) + 프로그래밍(20%) + 테스팅(40%)    
- 프로그래머의 생산성 : 프로그래머는 평균 하루에 10줄, 일년에 3000~4000줄 정도의 실행코드를 작성한다.   
시스템의 크기, 응용분야의 난이도에 따라 큰 차이를 보인다.    
cmm/iso 등 최근 품질 관련 모델들은 사용자 만족도에 중점을 두고 있다.    
생명 관련 SW / 핵 관련 SW : 버그 발생시 문제가 크다. 이런 SW는 테스트에 시간과 비용이 많이 들어간다. 반면, 사무용 SW 이런 종류는 테스트와 개발이 빠르다.    
- 프로그램의 오류 : 제품이 완료되어 배달된 후 발견되는 오류는 1000줄당 평균 4개 이하    
개발과정에서 발견되는 오류는 1000줄 당 약 50~60개 정도.    
최대한 많은 오류를 출고 전에 찾아 해결하는 것이 품질보증을 위해 필수적이다.    
소프트웨어의 품질은 생산성보다 더 핵심적인 현안이다.   
오류의 발견이 늦어질수록 오류를 고치는 비용이 증가한다.   
recall 제도는 소비자를 보호하고, 고객의 권리를 대폭 강화하는 것으로 산업분야에 확산되고 있다.   
사용자의 관점이 제품에 반영될때 품질 향상이 가능.   
- 사용자가 발견하는 시스템 오류의 원인 : 제안서와 사용자 요구사항에 대한 잘못된 이해   
개발과정에서 가장 어려운 문제는 사용자의 요구를 정확히 파악하는 것.   
정확히 분석되어있지 않는 상황에서 개발에 들어가면 시스템이 제대로 만들어질 확률이 낮아진다.   
개발 이전에 목표를 구체적으로 확립하는 것은 성공의 열쇠   
- 유지보수하는데 드는 비용 : 개발비용의 2배    
개발비용 33% + 유지보수 비용 67%   
유지보수비용은 얼마나 체계적으로 만들어졌느냐에 반비례   
  
**2.2 소프트웨어의 위기**   
우리나라의 SW역사는 짧다.   
개발 역사동안 생산성이나 개발 방법에 있어 뚜렷한 전환점이 없다. 느리고 점진적인 변화.   
소프트웨어 고난(software affliction)   
기술의 낙후함과 전문인력 부족현상.   
- 소프트웨어 위기의 원인   
+ 생산성이 사용자들의 요구를 따라가지 못한다   
기대는 점점 커지고, 생산성은 증대되지 않는다. 제안서만을 가지고 요구사항을 정확히 파악하기 어렵다.   
사용자와 개발자 간의 의견교환이 미흠   
+ 소프트웨어 품질이 향상되지 못하고, 유지보수가 힘들다.   
결과물을 공정 후반부에 가서야 얻을 수 있다.   
유지보수하는 데 많은 비용이 소모된다.   
소프트웨어의 품질 관리는 하드웨어보다 더 어렵다.   
+ 관리자나 엔지니어들이 새로운 기술에 대해 잘 모르고, 과거의 경험에 의해 코딩에 접근한다.   
기업은 장기적인 안목에서 관리자와 개발자들에 대한 교육과 훈련을 지속적으로 제공해아함    
+ 소프트웨어는 체계적인 접근방법이 많지 않아 품질향상이 어렵다.   
객체지향 개발방법론은 품질향상을 위한 좋은 기법 중 하나   
+ 프로젝트 개발 일정과 소용비용 예측이 매우 부정확   
다른 공학에 비해 역사와 경험이 적다.   
관리자들이 소프트웨어 개발에 대한 공학지식이나 경험이 부족한 경우가 많다.    
   
**2.3 소프트웨어 위기의 해결책**   
소프트웨어 개발은 기술적 문제 뿐만 아니라 관리적인 측면에서 조직적으로 문제를 극복하려는 노력을 요구   
참여한 모든 사람들이 문제점에 대한 정확한 인식과 목표를 가지고, 해결방법과 과정을 공유해야 한다.   
   
**2.4 소프트웨어에 대한 오해**   
**2.4.1 관리자의 오해**   
관리자는 의사결정에 결정적인 역할. 개발자들은 관리자의 지시를 따라간다.   
따라서 관리자들이 소프트웨어 개발의 본질을 이해하고, 제대로 된 방향을 제시할 때, 개발이 원활히 진행되고, 실무자들의 기술력과 제품의 품질이 향상될수 있다.   
관리자의 중요한 임주 중 하나는 실무자들의 기술력 향상, 성장 지원   
강의자료 참고    
**2.4.2 고객의 오해**   
고객은 소프트웨어에 대한 지식이 적다.
개발 경험이 적기 때문에 오해와 잘못된 기대를 가지기 쉽다.   
**2.4.3 엔지니어의 오해**
엔지니어들은 과거의 경험에 의해 프로그램을 작성한다.
그러나 제대로 된 소프트웨어 개발공법을 적용하는 훈련을 통해서만 자신의 기술력 성장 및 엔지니어로서의 생명력을 유지할 수 있다.   


   
**3. 소프트웨어 개발 방법론**   
소프트웨어 개발은 개발 방법, 개발 환경, 개발 관리에 따라 다양한 모습을 나타낸다.   
- 개발 방법   
소프트웨어를 어떻게 만들 것인가를 결정하는 기술적인 요소 제시   
프로젝트에 대한 계획과 추정, 요구사항 분석, 코딩 등 개발   
프로젝트 진행단계에서 요구되는 기법과 수행되어야 할 과제 포함   
- 개발 환경   
개발방법론을 지원해주기 위해 필요한 CASE, DBMS 등을 포함   
- 개발 관리   
관리는 개발에 필요한 공정단계, 각 단계별로 요구되는 입력과 결과물(문서,보고서,회의결과), 품질 보증을 위한 품질 검증과 제어장치 등에 대한 정의와 이의 실천을 의미한다.   
   
소프트웨어 개발 방법론(소프트웨어 공학 패러다임)   
- 폭포수 모델   
- 원형 패러다임  
- 나선형 모델   
- 4세대 기법   
패러다임의 선정은 프로젝트의 성격, 소요되는 기간, 방법과 도구 등에 의해 이루어진다.       
    
**3.1 폭포수 모델(Waterfall Model)**    
가장 오래되고 널리 사용되는 패러다임으로 고전적 라이프 사이클 패러다임으로 불린다.   
하향식 접근 방법을 사용, 높은 추상화 단계에서 낮은 추상화 단계로 옮겨가는 모델   
개발을 단계적으로 정의한 체계적이며 순차적인 접근방법을 사용한다.   
각 단계는 약간의 피드백이 이루어진 후 문서나 결과물이 동결되고, 그 다음 단계로 넘어간다.   
계획 - 요구사항 분석 - 설계 - 구현 - 테스트 - 유지보수       
- 장점   
프로젝트 진행과정을 세분화하여 관리가 용이하다   
- 단점   
대부분 순환이 발생하여 순차적 흐름을 따라가는데 어려움이 있다.     
고객의 요구사항을 초기에 구체적으로 기술하기 어렵다.     
작동하는 시스템이 후반에 얻어지므로, 중요한 문제점이 뒤에서 발견된다.   
   
**3.2 원형(Prototyping) 패러다임**    
고객이 요구사항을 구체적으로 정의하지 못하거나, 엔지니어들이 고객의 요구사항을 제대로 이해하지 못할 경우가 많다.    
이런 경우를 대비해 간단한 시제품(prototype)을 만들어 보여주는 것이 원형 패러다임   
사용자의 피드백을 시스템 개발 초기에 얻어낼 수 있다.   
시제품을 통해 요구사항을 구체적으로 규명할 수 있다.   
더욱 빨리 필요한 요구사항을 뽑아내고, 시스템에 반영시킬수록 더 안정되고 좋은 품질의 시스템을 생산할 수 있다.   
요구사항 분석-시제품 설계-시제품 개발-고객의 시제품 평가-시제품 정제-완제품 생산   
요구사항 분석 : 일부 요구사항만 정의하고, 나머지는 윤곽을 잡아놓는다.    
시제품 설계 : 사용자들이 볼 수 있는 면에 초점. 시제품에 포함되는 것과 배제되어야 할 것을 규명하는 것이 중요    
시제품 개발 : 어떻게 하면 시제품을 빨리 만들 수 있겠는가    
시제품 평가 : 가장 중요한 단계, 요구사항의 오류를 발견하고, 추가되야 할 요구사항을 발결    
시제품 정제 : 고객이 원하는 것을 만족하기 위한 시제품에 대한 조율. 다시 고객에게 평가되는 순환을 하게 되며, 고객이 요구사항에 대해 만족할때까지 반복    
완제품 생산 : 원하는 시스템을 개발. 시제품을 보완하여 완제품으로 하거나, 새롭게 완제품을 개발할 수도 있다.    
- 장점   
시제품으로 사용자들을 사전 교육하는데 활용할 수 있다.       
시스템이 개발되어 사용자가 실제 사용하기까지의 시간을 단축.      
시제품을 통해 최종 완제품을 테스트할 때 비교 대상으로 삼을 수 있다.   
- 단점   
완제품에 대한 오해를 불러일으킬 수 있다.   
시제품에서 완제품으로 가는데 많은 변화가 예상된다.   
시스템의 극한 상황에 대한 성능평가가 어렵다.    
다른 시스템과의 교류,통합에 대한 결과를 쉽게 얻기가 힘들다   
- 이런 단점에도 불구하고, 시제품을 쉽고 빠르게 만들 수 있는 도구들의 개발에 힘입어 많은 응용분야에서 효과적으로 활용되고 있다.    
   
**3.3 나선형(Spiral) 패러다임**   
폭포수 모델과 원형 패러다임의 장점에 새로운 요소인 위험분석(risk analysis)을 추가하여 만든 것   
시스템을 개발하면서 생기는 위험을 관리하고 최소하려는 것이 주 목적   
시스템의 위험 수위가 높을수록 나선형 패러다임을 선택한다.   
계획 및 정의 - 위험 분석 - 개발 - 고객 평가    
계획 및 정의 : 요구사항을 모으고 프로젝트 계획을 수립, 시스템의 목표와 제약조건에 대한 차선책이 평가,고려될 수 있다. 이러한 평가과정은 프로젝트 위험원인을 규명하는데 효과적으로 사용된다    
위험분석 : 초기 요구사항에 근거하여 위험이 규명된다. 정보를 찾아내는 활동을 통해 불확실성과 위험을 줄여나간다. 프로젝트를 계속 진행할 것인지(GO), 중단할 것인지(NO-GO)를 결정한다.    
개발 : 위험에 대한 평가 이후 개발한다. 어떠한 패러다임이 적용되어 시스템 개발이 이루어질 것인가 하는 개발 모델을 결정. 시제품 또는 최종제품을 만드는 과정    
고객 평가 : 고객에 의해 시스템에 대한 평가가 이루어지고, 고객은 시스템 수정을 요구하기도 한다. 엔지니어링의 결과는 시뮬레이션 모델, 시제품, 실제 시스템일 수도 있다. 고객 평가에 의해 다음 결과물을 계획한다.       
- 장점   
나선형 모델은 비용이 많이 들고, 시간이 오래 걸리는 큰 시스템을 구축하는데 가장 현실적인 방법(예: 초고속 정보통신망 개발, 큰 국책사업, 대형 사업)   
성과를 보면서 조금씩 투자하여 위험부담을 줄일 수 있다.   
- 단점 및 한계점   
모델이 복잡하여 프로젝트 관리 자체가 어렵다.    
많은 고객을 상대로 하는 상업용 제품에 적용하기 힘들다.(많은고객->많은 의견, 적용하기 어렵다)   
새로운 접근방법이라, 충분한 검증을 거치지 못했다.    
- 객체지향 개발방법론 : 원형 패러다임과 나선형 모델 등 점진적인 시스템 개발을 가능하게 하는 우수한 기법   

**3.4 4세대 기법(4th Generation Techniques)**    
CASE를 비롯한 자동화 도구들을 이용하여 요구사항 명세서로부터 실행코드를 자동으로 생성할 수 있게 해주는 방법    
그러나 현재 4GT 도구들은 고급언어를 실행코드로 바꿔줄만큼 정교하지 못하다.    
현재 부족한 점이 많아 많이 활용되지 못하고 있다    
앞으로 생산성에 대한 많은 요구와 소프트웨어 위기를 해결하기 위해 여러 응용분야에서 폭넓게 사용될 전망이다.   

**3.5 애자일(Agile) 방법론**    
기존의 방법론은 프로젝트의 본질적인 목표보다 계획 수립, 문서화, 품질 관리 등 부수적,추가적인 작업을 위해 오버헤드 비용을 과다하게 요구하는 것이 일반적이다.    
이런 무거운 소프트웨어 개발 방법론을 만족하지 못한 개발자들이 좋은 것을 빠르고 낭비없이 만들기 위해 1990년대 민첩성과 실용성을 앞세운 가벼운 경량급 개발방법론인 애자일 기법을 제안했다.    
필요한 요구를 그때 그때 더하고 수정하는 코드 중심의 점진적 개발방법    
단순성, 의사소통, 피드백, 용기를 기반한 “고객에게 최고의 가치를 가장 빨리 전달”    
협업과 변화에 대한 빠른 대응에 가치를 두고, 쪼개진 수행 과정을 통해 소규모 목표(WHAT)를 달성해 나감    
변화에 신속히 대처하기 위한 엔진 역할을 하는 것은 iteration.(과거 경험에 의존한다.)    
**3.5.1 기술적 부채(technical debt)**    
기존의 결함들로 인해 새로운 기능을 개발하거나 확장하는데 어려움이 발생하는 것.    
과거의 내린 결정의 결과가 미래에 부정적인 영향을 미치는 것    
소프트웨어의 경우 무형의 결과물이라, 기술적 부채가 스며 들어갈 곳이 많다.   
처음부터 올바르게 만들 수 있는 탁월한 기술력과 도덕 정신이 뒷받침되어야 한다.    
기술적 부채는 쌓일수록 해결하기 어려워지고, 수리 비용이 높아진다.    
**3.5.2 리팩토링(refactoring)**   
소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 기존 코드의 설계를 개선하는 기술   
동작이나 외부행위를 바꾸지 않고, 내부 구조를 바꾸며 점진적으로 설계를 향상시킨 기법    
리팩토링은 잘못된 설계에서 나타나는 기술적 부채를 감소시켜 쾌적한 환경을 조성하기 위한 노력이다.   
프로그래머의 직감에 의존하여 어느 부분이 리팩토링을 필요로 하는지 발견한다.   
중복된 코드, 긴 메소드, 거대한 클래스   
애자일에서는 리팩토링을 위한 별도의 절차나 시간을 할애하지 않고, 코드 구현의 일부분으로 취급한다.   
코드리뷰, 주석 처리    
버그를 발견,수정하는데 도움을 주며, 빠른 작업 속도를 얻을 수 있다.   
**3.5.3 객체지향 기법의 적용**   
객체지향 기술은 시스템을 수평적인 모습으로 설계 가능하게 하며, 재사용성을 확장시킨다.   
기존 코드의 영향을 최소화하면서 새로운 메소드나 코드를 추가할 수있다.   
애자일에서 필수적으로 요구되는 적응성과 재사용성을 극대화할수 있는 방법은 객체지향 기술.   
**3.5.4 애자일 기술의 장점**   
소프트웨어 개발 프로젝트의 낮은 성공률 때문에 보다 빠른 프로토타입의 중요성이 점점 높아지고 있고, 릴리즈 주기도 점점 짧아지고 있어, 애자일 기술의 프로세스와 가치에 부합된다.   
작고 쉽게 도입할 수 있고, 비용과 위험도도 상대적으로 낮다.    
애자일 기법은 형식이라기 보다는 마음가짐이고, 프로세스 중심이 아닌 사람 중심이며, 사람들 간의 참여와 소통에 관한 문제이다.   
**3.5.5 애자일 도입의 어려움**   
아직 성공사례가 많지 않다. 성공하기 위해서는 개발자와 고객이 함께 협업하며 프로젝트를 진행해야 한다.    
프로젝트 팀원들에게 요구되는 역량 : 반복을 여러번 수행하는 점진적인 개발. 구성원들은 개발 프로세스에 적응하기 이전에 먼저 소프트웨어공학, 객체지향 기술에 대해 충분히 이해하고 숙달된 개발자여야 한다.    
고객의 참여를 이끌어내기 힘들다. 전 과정에 고객의 참여가 필요하다.   
  
## 7. 학습 내용에 대한 개인적인 총평   
+ 정말 많은 개발방법론이 존재하고, 각각의 장단점을 파악할 수 있었다.
+ 방대한 이론을 타이핑하다보니 손가락이 아프다,, 요점만 적어야 하나 싶기엔 중요한 내용이 많다.
+ 실무에 들어가서 개발의 전체적인 과정을 겪어보고 싶다는 생각이 들었다.
+ 전체적인 개발 과정을 경험하고 나면, 개발한 소프트웨어에 더 애착이 갈 수 밖에 없을 것 같다.
+ 소프트웨어의 개발의 궁극적인 목적은 고객만족이다. 품질보증을 통해 고객의 요구사항을 만족시킬 수 있어야 한다.
+ 객체지향 방법론에 대한 이해가 필수적이라는 생각이 든다.

         
## 8. 다음 학습 계획
+ Divide and Conquer 알고리즘 학습