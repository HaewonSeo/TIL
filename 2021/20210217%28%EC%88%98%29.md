## 1. 학습 날짜
+ 2021-02-17(수)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ Ff_printf

## 4. 동료 학습 방법


## 5. 학습 목표
+ Ft_printf 학습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 5시간    
    
### VScode setting

- tasks.json : build 설정
    - args 를 추가할 경우, "" 안에 공백이 있으면 안됨. 빌드 시 " "그대로 출력된다.

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc build active file",
            "command": "/usr/bin/gcc",
            "args": [
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}",
                "-L${fileDirname}",
                "-lftprintf"
            ],
            "options": {
                "cwd": "/usr/bin"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

- launch.json : debug 설정

```json
{
	// IntelliSense를 사용하여 가능한 특성에 대해 알아보세요.
	// 기존 특성에 대한 설명을 보려면 가리킵니다.
	// 자세한 내용을 보려면 https://go.microsoft.com/fwlink/?linkid=830387을(를) 방문하세요.
	"version": "0.2.0",
	"configurations": [

		{
			"name": "gcc - 활성 파일 빌드 및 디버그",
			"type": "cppdbg",
			"request": "launch",
			"program": "${fileDirname}/${fileBasenameNoExtension}",
			"args": [],
			"stopAtEntry": false,
			"cwd": "${workspaceFolder}",
			"environment": [],
			"externalConsole": false,
			"MIMode": "gdb",
			"setupCommands": [
				{
					"description": "gdb에 자동 서식 지정 사용",
					"text": "-enable-pretty-printing",
					"ignoreFailures": true
				}
			],
			"preLaunchTask": "C/C++: gcc build active file",
			"miDebuggerPath": "/usr/bin/gdb"
		}
	]
}
```

- launch.json의 preLaunchTask와 task.json의  label의 내용이 같아야 한다.

### VScode 디버그 방법

- 빌드하려는 파일에서 `shift + ctrl + B` 하여 빌드한 후, `F5` 를 눌러 디버그

### true, false

- ft_printf를 하다가 내가 지금까지 큰 오해를 하고 있었다는 사실을 알게되어 충격적이다.
- false : 0
- true : 0이 아닌 모든 수.. **음수도 포함..!**
- **음수도 true다!!**

### 부호 있는 자료형(signed)의 비트 연산

- [https://dojang.io/mod/page/view.php?id=183](https://dojang.io/mod/page/view.php?id=183)

### 오버플로우와 언더플로우

- [https://dojang.io/mod/page/view.php?id=32](https://dojang.io/mod/page/view.php?id=32)
- ft_atoi()를 다시 보다가 학습하게 된 내용
- int nb에 2,147,483,648을 저장하는 경우, 오버플로우가 발생하게 된다.
- 2,147,483,647 : unsigned, signed 어느 것으로 읽어도 2,147,483,647이다.

0111 1111. 1111 1111. 1111 1111. 1111 1111.

- 2,147,483,648(unsigned로 읽는 경우) :

1000 0000. 0000 0000. 0000 0000. 0000 0000.

→ -2,147,483,648(signed로 읽는 경우)

int의 범위는 -2,147,483,648 ~ 2,147,483,647 이다. 또한, signed인 경우 맨 앞 비트가 0이면 양수, 1이면 음수이라는 것을 기억하자.

2,147,483,647보다 큰  2,147,483,648이 저장되는 것은 오버플로우가 발생한 것이고,  따라서, int 범위의 최소값인 -2,147,483,648으로 저장되는 것이다.

- ft_atoi()

    ```c
    #include <stdio.h>
    #include <stdlib.h>

    int ft_isspace(int c)
    {
    	if(c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' || c == ' ')
    		return(1);
    	return(0);
    }

    int ft_atoi(const char *str)
    {
    	int nb;
    	int i;
    	int sign;

    	nb = 0;
    	i = 0;
    	sign = 1;
    	while(ft_isspace(str[i]) == 1)
    		i++;
    	if(str[i] == '-' || str[i] == '+')
    	{
    		if(str[i] == '-')
    			sign = -1;
    		i++;
    	}
    	while(str[i] >= '0' && str[i] <= '9')
    		nb = (10 * nb) + (str[i++] - '0');
    	printf("nb[p] : %p \n", &nb);
    	printf("nb[x] : %x \n", nb);
    	printf("nb[d] : %d \n", nb);
    	printf("nb[u] : %u \n", nb);
    	return(nb * sign);
    }

    int main (void)
    {
    	char *num1 = " \t\t+0";
    	char *num2 = " \t\t+0";
    	char *num3 = "  \n\n+2147483647";
    	char *num4 = "  \n\n+2147483647";
    	char *num5 = "  \n\n-2147483648";
    	char *num6 = "  \n\n-2147483648";
    	printf("%d\n", atoi(num1));
    	printf("%d\n\n", ft_atoi(num2));
    	printf("%d\n", atoi(num3));
    	printf("%d\n\n", ft_atoi(num4));
    	printf("%d\n", atoi(num5));
    	printf("[d]%d\n\n", ft_atoi(num6));
    	printf("[u]%u\n\n", ft_atoi(num6));
    	return(0);
    }

    // 실행 결과
    shw2662@DESKTOP-F8LA849:~/src$ ./a.out 
    0
    nb[p] : 0x7fffe3f7d06c 
    nb[x] : 0 
    nb[d] : 0 
    nb[u] : 0 
    0

    2147483647
    nb[p] : 0x7fffe3f7d06c 
    nb[x] : 7fffffff 
    nb[d] : 2147483647 
    nb[u] : 2147483647 
    2147483647

    -2147483648
    nb[p] : 0x7fffe3f7d06c 
    nb[x] : 80000000 
    nb[d] : -2147483648 
    nb[u] : 2147483648 
    [d]-2147483648

    nb[p] : 0x7fffe3f7d06c 
    nb[x] : 80000000 
    nb[d] : -2147483648 
    nb[u] : 2147483648 
    [u]2147483648
    ```
    
## 7. 학습 내용에 대한 개인적인 총평
+ gdb로 디버그를 하다가, vscode에서 디버그를 할 수 있도록 해야겠다고 생각하였다.
+ 그동안 많은 문제와 시련을 겪으며 실패했었는데, 오늘이 되어서야 성공하였다. 덕분에 컴파일 및 디버그가 수월해졌다.
+ 이번 경험을 잊지 않기 위해 노션에 기록해두었다.
+ 피신 때 작성한 atoi()함수를 보다가 의문이 생겨 자료형에 대해 학습하였다.
+ 결과적으로 type == 'x'에 대한 처리를 하다 생기는 의문점을 해결하는데도 도움이 되었다.

## 8. 다음 학습 계획
+ Ft_printf