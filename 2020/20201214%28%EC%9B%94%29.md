## 1. 학습 날짜
+ 2020-12-14(월)

## 2. 학습시간
+ 13:00 ~ 19:00 (자가)   
+ 20:00 ~ 24:00 (자가)
+ 총 학습시간 : 10시간

## 3. 학습 범위 및 주제
+ 데이터베이스

## 4. 동료 학습 방법


## 5. 학습 목표
+ 뷰와 시스템 카탈로그 학습
+ 동시성 제어 학습
+ 개념적, 논리적, 물리적 설계 단계 복습

## 6. 상세 학습 내용
+ 실제 코딩에 소요한 시간 : 0시간    
+ 데이터베이스 강의 수강 : 2시간    

<8. 뷰와 시스템 카탈로그>    
    
<8.1 뷰>    
    
뷰 : 가상 릴레이션    
    
뷰는 하나 이상의 기본릴레이션으로 부터 생성될 수 있고, 기본 릴레이션과 뷰의 조합으로 생성될 수 있다.    
    
- 릴레이션    
1. 기본 릴레이션(base relation) : 물리적으로 실제 저장되어 있는 릴레이션    
2. 가상 릴레이션(virtual relation)  : 뷰에 해당되는 것이 저장되어 있지 않다는 것을 의미. 우리는 기본 릴레이션을 통해서 뷰에 해당되는 내용을 검색하는 것이다.    
    
가상 릴레이션은 dynamic window(동적인 창)의 역할을 한다. 동적인 창은 시간에 따라 변하는 릴레이션의 특정 일부분을 창을 통해서 본다는 의미이다.    
snapshot(정적인 창) : 스냅샵을 뜨는 시점의 질의에 해당되는 내용을 기본 릴레이션으로부터 구해서 저장해 놓은 것.    
기본 릴레이션이 변경된다 하더라도 스냅샷의 내용은 변경되지 않고 동일하게 유지되는 반면에,    
뷰인 경우에는 기본릴레이션의 내용이 변경되면, 나중에 뷰를 통한 질의를 할 때 변경된 기본 릴레이션으로부터 질의를 수행해서 보여주게 된다.     
    
- 뷰의 장점/역할/쓰임새    
    
1. 복잡한 질의를 간단하게 표현    
    
2. 데이터 무결성 보장    
WITH CHECK OPTION 사용 시 : 뷰의 정의에 맞는 경우만 insert/update 등을 할 수 있다. 튜플이 뷰에서 사라지도록 튜플을 수정할 수도 없다.    
			SELECT문 내의 where절의 조건을 만족하지 않는 범위에서 뷰를 사용하게 되면 오류를 출력한다.    
3번 부서만을 엑세스 하는 뷰에서 사원의 부서번호를 3에서 2로 변경하게 되면, 튜플이 뷰의 정의에서 벗어나게 된다. 이런 경우에 오류를 내게 하는 것이 위 옵션이다.    
    
Q. with check option 이 없으면 무결성이 보장되지 않는건가요?    
A. 무결성이 보장되지 않는다기 보다는 무결성 체크가 하나 없어지게 되는 것이다.    
    
3. 데이터 독립성을 제공    
DB의 구조 변경으로 응용프로그램을 다시 작성해야 하는 상황이 발생.    
이 때, 원래 릴레이션에 해당하는 뷰를 작성하여 제공해준다면 기존 응용프로그램에서 사용하던 select문을 계속해서 사용할 수 있다.    
    
물리적 독립성 : DB에서 실질적으로 저장하는 방법이 변경되어도, 그 위의 DB의 구조나 응용프로그램, 즉, 개념적 설계가 변경되지 않는 것.    
논리적 독립성 : DB의 구조가 변경되더라도 그 위의 응용프로그램이 변경되지 않는 것    
    
4. 데이터 보안 기능을 제공    
기본 릴레이션의 일부 애트리뷰트만을 사용할 수 있도록 뷰를 정의하고, 기본 릴레이션에 대한 접근의 권한을 허용하지 않고, 뷰에 대한 접근만을 허용하게 한다.    
민감한 정보는 숨기고, 나머지 정보만을 공개할 수 있다.    
    
5. 동일한 데이터에 대한 여러가지 뷰를 제공함    
하나의 기본 릴레이션에 대해서 필요에 따라 여러개의 뷰를 정의해서 제공할 수 있다.    
사용자 그룹이 각자 특정 기준에 따라 접근할 수 있는 데이터가 다를 경우, 각 사용자 그룹에 맞는 뷰를 제공하여 각각 데이터를 접근하도록 한다.    
    
- 뷰의 갱신 : 검색에는 제약사항이 없는데, 갱신에는 몇 가지 제약이 있다.    
    
1. 한 릴레이션 위에서 정의된 뷰에 대한 갱신    
주어진 insert문은 수행된다. 3개의 애트리뷰트에만 값이 주어지고, 나머지 애트리뷰트는 값이 입력되지 않는다.(NULL 값이 입력된다.). 성공적으로 삽입 연산이 수행된다.    
   
    
2. 두 개의 릴레이션 위에서 정의된 뷰에 대한 갱신    
대부분의 관계DBMS에 갱신이 불가능하다. 조인이 정의된 뷰라도, 뷰의 한 튜플이 기본 릴레이션의 한 튜플과 정확하게 대응되는 경우에는 갱신을 허용하는 관계 DBMS도 있다.    
하지만, 이런 DBMS에서도 기본키의 값이 널인 투플은 엔티티 무결성 제약 조건에 의해 삽입이 거절된다.    
주어진 예에서 기본키인 사원번호에 대한 입력값이 없어 기본키가 NULL값을 갖게 되고, 따라서 삽입이 거절된다.    
    
3. 집단함수 등을 포함한 뷰에 대한 갱신    
주어진 예는 개별 투플들의 값을 임의로 변경해야만 가능할 것이다. 따라서 논리적으로 타당하지 않은 연산이고 명확하지 않다. 따라서, DBMS에서 수행을 거절한다.    
    
    
- 갱신이 불가능한 뷰    
1. 한 릴레이션 위에서 정의되었으나 그 릴레이션의 기본 키가 포함되지 않은 뷰    
기본키가 포함되지 않은 뷰에 대해 INSERT 하게 되면, 기본키는 입력값이 주어지지 않아 널이 되는데, 기본키에 널이 들어가는 것은 엔티티 무결성 제약조건에 위배된다.    
2. 기본 릴레이션의 애트리뷰트들 중에서 뷰에 포함되지 않은 애트리뷰트에 대해 NOT NULL이 지정되어 있을 때    
뷰를 통해서 삽입을 할 때, 뷰에서 정의되지 않는 애트리뷰트는 입력값이 없어 null을 갖게 되는데,    
not null이라는 도메인 제약조건과의 충돌이 발생하게 되어 그 뷰를 통해 insert가 불가능하게 된다.    
3. 집단함수가 포함된 뷰    
4. 조인으로 정의된 뷰 :조인이 들어간 경우 갱신이 가능할수도 있고, 불가능할 수도 있다. 일반적으로 갱신을 허용하지 않는 경우가 많다.    
    
    
- 갱신 가능성 기준에 따른 뷰들의 유형    
사용자가 정의할 수 있는 모든 뷰    
이론적으로 갱신이 가능한 뷰 / 불가능한 뷰    
상용관계DBMS들이 갱신을 허용하는 뷰    
    
이론적으로 갱신이 가능하지만, 구현하는데 엄청나게 어려운 경우가 있다.    
계산하고 체크하는 것들이 복잡하고, 시간이 오래걸리고, 구현이 어려운 경우가 있다.    
이런 경우는 제외하고 체크가 쉽고 빠르게 되는 경우만을 상용 DBMS들이 갱신이 허용한다.    
갱신이 허용되는 경우는 DBMS마다의 차이가 있다.    
    
    
<8.2 관계 DBMS의 시스템 카탈로그>    
    
시스템 카탈로그 = 메타데이터 = 데이터 사전 = 시스템 테이블    
    
- 시스템 카탈로그가 저장되는 구조     
어떤 형태로든 메타데이터를 저장하고 관리할수 있는 형태이면, 그 구조를 사용하면 된다.    
그러나 보통 관계DBMS에서 시스템 카탈로그는 일반 사용자의 릴레이션과 똑같은 형태(릴레이션 형태)로 저장된다. -> SIMPLE하지만 아주 중요한 내용이다.    
만약, 관계 DBMS에서 시스템 카탈로그를 릴레이션이 아닌 다른 형태로 저장되었다고 한다면, 카탈로그에 있는 정보를 검색하기 위해서는 릴레이션이 아니니깐 SQL문을 사용할 수 없다. 그러므로 별도의 질의나 방법을 만들어야 한다.    
그런데 그렇지 않고, 일반 릴레이션과 동일한 형태로 저장되기 때문에. 일반 릴레이션에서 사용하는 동일한 방법인 SQL을 통해 검색이 가능하다. 추가적인 질의 방법이 필요없다. 뒤에서 트랜잭션에 관한 내용을 공부하다 보면, 릴레이션에 대한 동시성 제어와 파손회복을 지원해주어야 하는데, 시스템 카탈로그도 릴레이션처럼 저장함으로써, 별도의 방법을 따로 구현할 필요없이 릴레이션을 처리하는 한가지 방법만 구현하면, 그 방법을 동일하게 적용하여 이 2 기능을 지원할 수 있다.    
    
- 시스템 카탈로그가 질의 처리에 어떻게 활용되는가?     
--> 시스템 카탈로그가 질의처리의 여러 단계에서 지속적으로 사용된다. 시스템 카탈로그는 여러 릴레이션으로 저장된다. 각각의 릴레이션은 다른 정보를 저장하고 있다.    
0. 문법적 오류를 검사    
1. SELECT 문에서 참조하는 릴레이션이 데이터베이스에 존재하는가를 검사함 -> SYS_RELATION 카탈로그가 사용된다.     
2. 릴레이션에 SELECT절에 열거된 애트리뷰트와 WHERE절에서 조건에 사용된 애트리뷰트가 존재하는가를 확인함 -> SYS_ATTRIBUTE 카탈로그가 사용된다.    
3. 애트리뷰트의 데이터 타입이 맞는지를 검사 -> SYS_ATTRIBUTE 카탈로그의 데이터 타입 정보에서 확인한다.    
4. 사용자가 애트리뷰트를 검색할 수 있는 권한이 있는가를 확인함 -> SYS_RELATION과 SYS_ATTRIBUTE에는 이 질의처리에 필요한 정보가 없다. 이런 단계를 거치려고 한다면, 이러한 정보를 모아놓은 카탈로그가 필요하다. 카탈로그에는 권한 테이블이 있다. 애트리뷰트/릴레이션별로 읽기/쓰기/수정 권한 등이 저장되어 있다.    
5. 애트리뷰트에 인덱스가 정의되어 있는지 확인함 ->  SYS_RELATION과 SYS_ATTRIBUTE에는 인덱스에 대한 정보가 없다. SYS_INDEX라는 카탈로그가 필요하다. SYS_INDEX에는 인덱스별로 정보를 가진다. 각 인덱스별로 어떤 릴레이션의 어느 애트리뷰트에 대해 인덱스를 정의하는지를 저장한다.    
    
- 관계 DBMS의 시스템 카탈로그    
1. SYS_RELATION    
여기서는 릴레이션 식별자가 RELID이지만, 일반적으로 별도의 번호를 부여하여 식별자로 사용하는 경우가 많다.    
RELWIDTH : 릴레이션 튜플을 저장하기 위한 BYTE수    
2. SYS_ATTRIBUTE     
애트리뷰트 식별자 : 애트리뷰트가 정의된 릴레이션 이름(AttrelID) + 번호(AttID)    
Attoff : 튜플을 저장하는 레코드 내에서 몇번쨰 위치에 해당 애트리뷰트가 저장되는지를 나타낸다.    
    
- 어떻게 카탈로그 테이블에 대한 정보들이 업데이트 되는가?    
일반적으로 SQL 종류 중 DDL이 있었는데, 이를 이용하여 데이터베이스 구조/객체 명령이 내려지게 되면, 연산이 수행되면서 해당되는 카탈로그 테이블이 갱신된다.    
    
인덱스를 선택하기 위해서는, 인덱스에 대한 통계정보를 카탈로그 테이블이 가지고 있어야 한다.    
이렇듯 질의처리, DBMS 관리를 위해서 다양한 종류의 카탈로그 테이블이 사용된다.    
    
    
----------------------------------------------------------    

<8.3 오라클의 시스템 카탈로그>    
오라클에서는 시스템 카탈로그를 데이터 사전이라고 부른다.    
    
DICTIONARY : 데이터 사전 테이블과 뷰에 관한 정보    
따라서 다른 사전이름을 모르는 경우 DICTIONARY 사전에서 찾을 수 있다.    
    
<9. 트랜잭션>    
    
<9.1 트랜잭션 개요>    
    
- 동시성 제어    
    
- 회복    
    
- 트랜잭션    
동시성 제어와 회복을 지원하기 위해 DB는 트랜잭션을 제공한다.    
    
1 .로그를 유지    
2. 여러 SQL을 하나의 트랜잭션으로 취급    
3.commit 과 메세지출력의 순서를 정확히 해야함    
     
- 트랜잭션의 특성 : ACID    
1. 원자성(Atomicity) : all or nothing.     
2. 일관성(Consistency) : 트랜잭션은 일관된 상태의 DB를 새로운 일관된 상태의 DB로 변경된다. 트랜잭션 수행도중에는 일시적으로 불일치 상태에 있을 수 있다.    
일관성은 무결성 제약조건과 응용 프로그램에서의 논리를 유지(만족)하는 것을 말한다.     
은행에서 계좌이체의 예. 새로운 상태에서도 이전 상태와 동일한 총액을 유지하는 것    
3. 고립성(Isolation) : 독립성이라고도 함. 여러 트랜잭션이 동시에 수행되는데, 하나의 트랜잭션은 다른 트랜잭션들이 동시에 수행된다는 것에 전혀 영향을 받지 않고, 자기 혼자만 돌아가는 것과 같은 효과를 가져야 한다는 것을 의미한다. 다양한 고립수준에 대해서는 뒤의 절에서 다시 이야기 할 예정임    
4. 지속성(Durability) : commit 한 이후에는 어떤일이 발생하더라도, 커밋한 트랜잭션의 내용은 데이터베이스에 항상 남아있어야 한다.    
    
- 트랜잭션의 완료(commit)    
COMMIT WORK    
    
- 트랜잭션의 철회(abort)    
ROLLBACK WORK    
    
- 트랜잭션이 성공하지 못하는 원인    
    
<9.2 동시성 제어>    
    
- 스케쥴 : DBMS에서 트랜잭션을 수행하는 순서, 트랜잭션은 여러개의 연산들로 구성된다.    
1. 직렬스케줄 : 하나의 트랜잭션을 차례대로 수행하는 것을 말한다.    
2. 비직렬 스케줄 : 트랜잭션들이 차례대로 수행되지 않고, 섞여서 수행된다. OPERATION들이 섞여서 수행된다.    
3. 직렬가능 : 비직렬 스케줄 중에 올바르지 않는 것이 있고, 올바른 것이 있다. 비직렬 스케줄 중에서 직렬스케줄의 결과와 동등한 것을 직렬가능하다고 한다.    
    
T1 : O11,O12,O13    
T2 : O21.O22,O23,O24    
T3 : O31,O32    
    
직렬스케줄 : T1-T2-T3 or T2-T3-T2 or ...총 6개의 직렬스케쥴이 가능하다. N개의 트랜잭션이라면 N!개의 직렬 스케줄이 가능하다.    
비직렬스케줄 : O11-O21-O22-O12... -> 9!/(2!*3!*4!). 각각의 트랜잭션에서의 순서는 유지되어야 한다.    
따라서 (2!*3!*4!)을 나누어주어야 한다. 비직렬스케쥴이 직렬스케줄에 비해 더많은 경우가 있다.    
    
모든 비직렬 스케줄이 유용한 스케줄인가? 그렇지 않다.    
비직렬 스케줄 중에는 올바르지 않는 것이 있고, 올바른 것이 있다.    
올바른 스케줄이란? 비직렬 스케줄 중에서 직렬스케줄 중 어떤 하나의 결과와 동등한 것을 직렬가능하다고 한다.    
    
어떤 경우의 결과가 동일한가?(Equivelent하다는 것은 각각의 트랜잭션에서 write하는 그 데이터 항목들의 값들이 동등하면 된다.)    
사실 결과값만 두고 보면 어떤 특정한 값일때에 한해서 우연하게 결과값이 동일할 수도 있다. 이런 경우는 제외되어야 한다.    
정확하게 말하자면, 특정 데이터에 대해 그 데이터 항목의 연산이 수행되는 순서가 동일하다고 한다면, 직렬가능 스케줄이라고 한다.    
    
예를 들어 A,B 2개의 데이터가 있다고 한다면,    
서로 다른 스케줄로 트랜잭션을 수행했을 때, A와 B의 값의 변경된 결과가 같으면 같은 스케줄이라고 할 수 있다.    
특정 A와 B의 값에 대해서 우연하게 같은 결과를 갖는 경우는 제외하기 위해서    
(가정)    
A에 관련된 연산 -> O11. O23, O24, O31    
B에 관련된 연산 -> ~~~    
S1 : T1-T2-T3 으로 수행이 된다.    
A에 관련된 오퍼레이션들의 순서는 O11. O23, O24, O31이여야 한다는 것이다.    
그래서 어떤 스케줄이 비직렬스케줄인데 이 비직렬스케줄에서 A에 대한 순서가 O11. O23, O24, O31와 같이 나오고,    
또 B에 대한 순서가 ~~~와 동일하게 나온다면 그것은 서로 Equivelent하다고 한다.    
    
Q. 직렬 가능이 여러가지일 수도 있나요?    
A. 어떤 비직렬스케줄이 하나 있는데 그것이 어떤 직렬스케줄과 같다고 물어보면, 같은 직렬 스케줄은 1가지만 나올 수 있다. 직렬스케줄의 순서와 일치가 되야하므로.    
-> 어떤 직렬스케줄과 같은 비직렬스케줄은 여러개가 있을 수 있다.    
앞에서 이야기했듯이, 결과값이 같은 것이 직렬가능이라 한다면 우연히 같을 경우도 있기 때문에 오퍼레이션의 순서로 판단해야 한다.    
    
equivelent에는 2가지 종류가 있다.    
result equivelent : 결과값만으로 따지는 경우. 이는 우연히 같아진 경우가 있어 사용을 거의 안한다.    
complement equivelent : 오퍼레이션의 순서로 따지는 경우. 이를 이용해서 equivelent를 판단한다.    
    
- 데이터베이스 연산    
    
- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제    
1. 갱신 손실(loss update)    
2. 오손 데이터 읽기(dirty read)    
3. 반복할 수 없는 읽기(unrepeatable read)    
    
--------------------------------------------------------    

<로킹(locking)>    
동시성 제어를 하기 위한 기법    
로크(lock) : 데이터를 엑세스하려고 하면, 먼저 로크를 요청하고 로크가 획득되었을 때만 엑세스가 가능하다.    
공유모드 : 읽기는 여러 트랜잭션이 동시에 가능하다. 읽기의 경우는 공유모드를 요청함.    
독점모드 : 쓰기는 다른 읽기/쓰기와 동시에 이루어질 수 없다. 이 경우 독점모드를 요청해야 함.    
    
(page37)    
단순히 로킹을 사용한다고 해서 동시서 제어 문제가 완벽하게 해결되는 것은 아니다.    
T1이 수행되기 전에 A=B라면, 수행 후에도 A=B 여야 한다.    
T2가 수행되기 전에 A=B라면, 수행 후에도 A=B 여야 한다.    
    
따라서, T1을 수행하고 T2를 수행하든, 순서를 바꾸어 수행하든, 직렬스케줄을 사용하면 최종적으로 A=B여야 한다.    
그러나, 그림의 스케줄을 따르면, A!=B가 된다.    
이는 unlock(A)로 A에 대한 로크를 일찍 해제하여 T2가 A와 B가 동일하지 않은 상태에서 데이터를 접근했기 때문이다.    
    
로크를 획득하고 해제하는 <시점>에 대한 규칙이 있어야 한다.    
올바른 동시성 제어를 위해서는 2단계 로킹 프로토콜을 사용하여야 한다.    
- 2단계 로킹 프로토콜(2-phase locking protocol)    
1단계 : 로크 확장단계(로크 요청)    
2단계 : 로크 수축단계(로크 해제)    
일반적으로 한꺼번에 해제되는 방법이 사용된다. -> 트랜잭션을 완료하는 시점(정확하게 commit이 끝난 이후).    
- 단계적 해제 vs 한꺼번에 해제 (차이점)     
로크는 메모리를 많이 차지할 수 있다. 로크는 자원을 점유한다. 일찍 해제하는 것이 좋다.]    
단계적 해제하면, 메모리를 점유율이 낮아지는 효과가 있다.    
그러면 단계적 해제가 좋은 것인가?    
단계적으로 해제한다고 할때, 트랜잭션을 커밋하기 전에 로크를 풀어서 읽어간다고 한다면, 나중에 트랜잭션이 철회될 수 있다.    
이 경우 오손데이터 읽기 문제가 발생할 수 있다.    
따라서 한꺼번에 해제하는 방법을 일반적으로 사용한다.    
    
로크포인트 : 필요한 로크를 모두 걸어놓은 시점    
    
- 데드록(deadlock)    
서로 상대방이 보유하고 있는 로크를 기다리며 트랜잭션 수행이 멈추게 되는 것이 데드록    
데드록이 멈춰있는지 알아내는 방법 : 그림에서 화살표를 따라가면 사이클이 있다는 것을 알 수 있다. 이처럼 로크 요청 그래프에서 사이클이 있으면 데드록이 발생한 것임    
    
- 데이터베이스 시스템에서 데드락을 해결하는 방법    
데드락이 발생하기 놔두고, 시스템이 주기적으로 데드락이 발생했는지를 체크한다.    
어떻게 체크하나?    
로크요청그래프에서 사이클이 있는지를 확인한다.    
로크요청그래프에서 사이틀이 있으면 데드락이 발생한 것임    
로크요청그래프 : 노드-트랜잭션, 로크(데이터 항목).방향성 있는 그래프    
    
데드락을 풀려면?    
사이클에 포함되어 있는 트랜잭션 중 하나를 골라서 철회시키면 된다.     
그러면 사이클을 풀 수 있다.    
여러개의 트랜잭션이 사이클에 포함되어 있을 때, 어떤 트랜잭션을 철회시키는 것이 좋은가?    
1. 방금 시작한 트랜잭션    
2. 오래전에 시작한 트랜잭션    
-> 방금 시작한 트랜잭션을 철회하는 것이 좋다.    
트랜잭션을 철회한다는 것을 트랜잭션이 수행한 연산을 철회하는 것인데,    
오래전에 시작한 트랜잭션을 철회하면 비용이 많이 소모된다.    
반면에 방금 시작한 트랜잭션을 철회하면 비용이 적게 든다.    
    
    
로크단위들 간에는 계층구조가 있다.    
- 다중단위로크(multiple granularity)    
로크의 대상이 되는 데이터 항목의 단위는 일반적으로 튜플이다.    
트랜잭션들이 많은 투플을 접근하는 데이터베이스 응용에서 투플 단위로만 로크를 한다면,    
로크 테이블에서 로크 충돌을 검사하고, 로크 정보를 기록하는 시간이 오래 걸리고 자원도 많이 사용한다.    
    
(page47)    
b1에 있는 5개의 투플도 모두 독점로크가 걸린다.    
다시 말하면, 독점로크가 걸린다기 보다는, 독점로크를 개별투플에 걸지 않고도 엑세스가 가능하다.    
T1이 5개의 투플에 독점모드로 접근할 수 있다는 것이다.    
    
릴레이션을 전부 엑세스한다고 하면, 릴레이션 전체에 대해 로크를 요청하는 것이 좋다.    
    
T1이 블록 B1에 X-lock    
T2가 t3에 S-lock을 요청하면, 대기가 되어야 하는데. t3의 상위노드에 lock이 걸려있는지 어떻게 알 수 있나?    
-> 어떤 데이터 항목에 대해서 로크를 요청하게 되면, 해당 노드가 로크되었는지를 확인하는 것 뿐만아니라 해당 노드의 상위 레벨을 lookup을 한다.    
상위 노드의 로크 여부에 따라 로크를 허가할지 안할지를 결정하게 된다.    
    
T1이 t5에 X-lock 요청    
T2가 B2(t5의 상위노드)에 S-lock 요청    
-> 이경우 T2가 요청한 S-lock을 허용하면 안된다. 왜나면, t5에 X-lock이 걸려있기 때문에 허용하면 안된다.     
이경우 T2가 요청한 S-lock을 허용하면 안된다는 것을 어떻게 확인할 수 있나?    
-> 하위 레벨에 있는지 검사하는 것은 비용이 많이 든다.    
-> 어떤 노드에 락을 요청했을 때, 해당 노드뿐만 아니라 상위노드에게도 하위 노트에 락이 요청되었다는 것을 알려주어야 한다.    
-> 그런데, t5에 X-lock을 요청했는데 B2에 X-lock을 요청하면, B2는 블록전체가 X-lock이 걸린 것처럼 보인다.    
그래서 B2에 Intension X-lock을 건다. (IX-lock, 의도가 있다.)    
따라서, 나중에 T2가 S-lock을 요청하게 되면, 하위노드에 락이 있다는 것을 알고, S-lcok을 대기시킨다.    
    
    
지금까지 동시성 제어가 없을 때 발생하는 갱신손실, 오손데이터 읽기, 반복할 수 없는 읽기 3가지의 문제를 설명하였다.    
이를 해결하기 위해 2단계 로킹 프로토콜을 설명하였다.    
그런데, 동시성 제어가 없을 때 발생하는 팬텀문제라고 하는 또 다른 문제가 있다.    
- 팬텀 문제(phantom problem)    
정희연이라는 없던 사원이 유령처럼 등장한 것임    
트랜잭션의 고립성에 따르면, 모든 트랜잭션은 다른 트랜잭션이 수행되는 것과 상관없이 자기 혼자만 수행되는 것처럼 보여져야 하는데 그렇게 되지 못한 것임.    
    
- 팬텀과 반복할 수 없는 읽기 문제 비교 -> 마지막챕터에서 배운다.    
간단히 이야기하면, 반복할 수 있는 읽기는 이미 존재하는 데이터에 대해서만 같은 값을 읽는 것을 허용해주는 것이고, 기존에 없었던 데이터에 대해서는 처리를 못한다.    
팬텀문제를 해결한다는 것은 없었던 문제에서도 다시 생기는 문제까지도 해결하는 것,    
    

## 7. 학습 내용에 대한 개인적인 총평
+ 뷰와 시스템 카탈로그에 대해 학습하였다.
+ 동시성 제어와 이를 위한 로크에 대한 내용을 학습하였다.
+ 데이터베이스 설계의 개념적, 논리적, 물리적 단계에 대한 내용도 복습하였다.
+ 설계에 대한 흐름과 구체적인 내용을 파악하였다.
+ 프로젝트를 통해 설계를 직접 수행하니 이론에 대한 이해가 더 수월하였다. 

## 8. 다음 학습 계획
+ 데이터베이스 회복 및 권한 관리 학습